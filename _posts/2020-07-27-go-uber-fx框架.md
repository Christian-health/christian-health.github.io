## fx框架概述
软件包fx是一个**框架**，可以轻松地从可重用，可组合的模块中**构建应用程序**。Fx应用程序使用依赖注入来**消除全局变量**，而无需手动连接函数调用。与其他依赖注入方法不同，Fx与普通Go函数一起工作：您不需要使用struct标记或嵌入特殊类型，因此Fx可以自动与大多数Go包配合使用。下面的包级别示例解释了基本用法。如果你是新来的使用Fx框架的，从包级别示例开始！高级功能（包括命名实例、可选参数和值组）在In和Out类型下进行了说明。
### 测试Fx应用程序
要测试使用生命周期类型的函数或编写Fx应用程序的端到端测试，请使用go.uber.org/fx/fxtest包裹。
```go
package fx_test

import (
	"context"
	"log"
	"net/http"
	"os"
	"time"

	"go.uber.org/fx"
)

// NewLogger constructs a logger. It's just a regular Go function, without any
// special relationship to Fx.
//
// Since it returns a *log.Logger, Fx will treat NewLogger as the constructor
// function for the standard library's logger. (We'll see how to integrate
// NewLogger into an Fx application in the main function.) Since NewLogger
// doesn't have any parameters, Fx will infer that loggers don't depend on any
// other types - we can create them from thin air.
//
// Fx calls constructors lazily, so NewLogger will only be called only if some
// other function needs a logger. Once instantiated, the logger is cached and
// reused - within the application, it's effectively a singleton.
//
// By default, Fx applications only allow one constructor for each type. See
// the documentation of the In and Out types for ways around this restriction.
func NewLogger() *log.Logger {
	logger := log.New(os.Stdout, "" /* prefix */, 0 /* flags */)
	logger.Print("Executing NewLogger.")
	return logger
}

// NewHandler constructs a simple HTTP handler. Since it returns an
// http.Handler, Fx will treat NewHandler as the constructor for the
// http.Handler type.
//
// Like many Go functions, NewHandler also returns an error. If the error is
// non-nil, Go convention tells the caller to assume that NewHandler failed
// and the other returned values aren't safe to use. Fx understands this
// idiom, and assumes that any function whose last return value is an error
// follows this convention.
//
// Unlike NewLogger, NewHandler has formal parameters. Fx will interpret these
// parameters as dependencies: in order to construct an HTTP handler,
// NewHandler needs a logger. If the application has access to a *log.Logger
// constructor (like NewLogger above), it will use that constructor or its
// cached output and supply a logger to NewHandler. If the application doesn't
// know how to construct a logger and needs an HTTP handler, it will fail to
// start.
//
// Functions may also return multiple objects. For example, we could combine
// NewHandler and NewLogger into a single function:
//
//   func NewHandlerAndLogger() (*log.Logger, http.Handler, error)
//
// Fx also understands this idiom, and would treat NewHandlerAndLogger as the
// constructor for both the *log.Logger and http.Handler types. Just like
// constructors for a single type, NewHandlerAndLogger would be called at most
// once, and both the handler and the logger would be cached and reused as
// necessary.
func NewHandler(logger *log.Logger) (http.Handler, error) {
	logger.Print("Executing NewHandler.")
	return http.HandlerFunc(func(http.ResponseWriter, *http.Request) {
		logger.Print("Got a request.")
	}), nil
}

// NewMux constructs an HTTP mux. Like NewHandler, it depends on *log.Logger.
// However, it also depends on the Fx-specific Lifecycle interface.
//
// A Lifecycle is available in every Fx application. It lets objects hook into
// the application's start and stop phases. In a non-Fx application, the main
// function often includes blocks like this:
//
//   srv, err := NewServer() // some long-running network server
//   if err != nil {
//     log.Fatalf("failed to construct server: %v", err)
//   }
//   // Construct other objects as necessary.
//   go srv.Start()
//   defer srv.Stop()
//
// In this example, the programmer explicitly constructs a bunch of objects,
// crashing the program if any of the constructors encounter unrecoverable
// errors. Once all the objects are constructed, we start any background
// goroutines and defer cleanup functions.
//
// Fx removes the manual object construction with dependency injection. It
// replaces the inline goroutine spawning and deferred cleanups with the
// Lifecycle type.
//
// Here, NewMux makes an HTTP mux available to other functions. Since
// constructors are called lazily, we know that NewMux won't be called unless
// some other function wants to register a handler. This makes it easy to use
// Fx's Lifecycle to start an HTTP server only if we have handlers registered.
func NewMux(lc fx.Lifecycle, logger *log.Logger) *http.ServeMux {
	logger.Print("Executing NewMux.")
	// First, we construct the mux and server. We don't want to start the server
	// until all handlers are registered.
	mux := http.NewServeMux()
	server := &http.Server{
		Addr:    ":8080",
		Handler: mux,
	}
	// If NewMux is called, we know that another function is using the mux. In
	// that case, we'll use the Lifecycle type to register a Hook that starts
	// and stops our HTTP server.
	//
	// Hooks are executed in dependency order. At startup, NewLogger's hooks run
	// before NewMux's. On shutdown, the order is reversed.
	//
	// Returning an error from OnStart hooks interrupts application startup. Fx
	// immediately runs the OnStop portions of any successfully-executed OnStart
	// hooks (so that types which started cleanly can also shut down cleanly),
	// then exits.
	//
	// Returning an error from OnStop hooks logs a warning, but Fx continues to
	// run the remaining hooks.
	lc.Append(fx.Hook{
		// To mitigate the impact of deadlocks in application startup and
		// shutdown, Fx imposes a time limit on OnStart and OnStop hooks. By
		// default, hooks have a total of 15 seconds to complete. Timeouts are
		// passed via Go's usual context.Context.
		OnStart: func(context.Context) error {
			logger.Print("Starting HTTP server.")
			// In production, we'd want to separate the Listen and Serve phases for
			// better error-handling.
			go server.ListenAndServe()
			return nil
		},
		OnStop: func(ctx context.Context) error {
			logger.Print("Stopping HTTP server.")
			return server.Shutdown(ctx)
		},
	})

	return mux
}

// Register mounts our HTTP handler on the mux.
//
// Register is a typical top-level application function: it takes a generic
// type like ServeMux, which typically comes from a third-party library, and
// introduces it to a type that contains our application logic. In this case,
// that introduction consists of registering an HTTP handler. Other typical
// examples include registering RPC procedures and starting queue consumers.
//
// Fx calls these functions invocations, and they're treated differently from
// the constructor functions above. Their arguments are still supplied via
// dependency injection and they may still return an error to indicate
// failure, but any other return values are ignored.
//
// Unlike constructors, invocations are called eagerly. See the main function
// below for details.
func Register(mux *http.ServeMux, h http.Handler) {
	mux.Handle("/", h)
}

func Example() {
	app := fx.New(
		// Provide all the constructors we need, which teaches Fx how we'd like to
		// construct the *log.Logger, http.Handler, and *http.ServeMux types.
		// Remember that constructors are called lazily, so this block doesn't do
		// much on its own.
		fx.Provide(
			NewLogger,
			NewHandler,
			NewMux,
		),
		// Since constructors are called lazily, we need some invocations to
		// kick-start our application. In this case, we'll use Register. Since it
		// depends on an http.Handler and *http.ServeMux, calling it requires Fx
		// to build those types using the constructors above. Since we call
		// NewMux, we also register Lifecycle hooks to start and stop an HTTP
		// server.
		fx.Invoke(Register),
	)

	// In a typical application, we could just use app.Run() here. Since we
	// don't want this example to run forever, we'll use the more-explicit Start
	// and Stop.
	startCtx, cancel := context.WithTimeout(context.Background(), 15*time.Second)
	defer cancel()
	if err := app.Start(startCtx); err != nil {
		log.Fatal(err)
	}

	// Normally, we'd block here with <-app.Done(). Instead, we'll make an HTTP
	// request to demonstrate that our server is running.
	http.Get("http://localhost:8080/")

	stopCtx, cancel := context.WithTimeout(context.Background(), 15*time.Second)
	defer cancel()
	if err := app.Stop(stopCtx); err != nil {
		log.Fatal(err)
	}

	// Output:
	// Executing NewLogger.
	// Executing NewMux.
	// Executing NewHandler.
	// Starting HTTP server.
	// Got a request.
	// Stopping HTTP server.
}
```
### Constants
```const DefaultTimeout = 15 * time.Second```  
`DefaultTimeout is the default timeout for starting or stopping an application. It can be configured with the StartTimeout and StopTimeout options.  `  
DefaultTimeout是启动或停止应用程序的默认超时。 可以使用StartTimeout和StopTimeout选项进行配置。
```go 
type App struct {
	err          error
	container    *dig.Container
	lifecycle    *lifecycleWrapper
	provides     []provide
	invokes      []invoke
	logger       *fxlog.Logger
	startTimeout time.Duration// 启动超时  fx.DefaultTimeout = fx.StartTimeout(1000*time.Second)
	stopTimeout  time.Duration //停止超时
	errorHooks   []ErrorHandler
	validate     bool

	donesMu sync.RWMutex
	dones   []chan os.Signal
}
```
```const Version = "1.13.0"```  
`Version is exported for runtime compatibility checks.  ` 
```
使用fx.Version配置
```
Version是可以被导出的，用来进行运行时兼容性检查

### Variables
```var NopLogger = Logger(nopLogger{}) ```  
`NopLogger disables the application's log output. Note that this makes some failures difficult to debug, since no errors are printed to console.  `  
NopLogger禁用应用程序的日志输出。 注意，由于没有错误打印到控制台，这使得某些故障难以调试。  
```
使用 fx.NopLogger 配置
```

### func ValidateApp
```func ValidateApp(opts ...Option) error  ```  
`ValidateApp validates that supplied graph would run and is not missing any dependencies. This method does not invoke actual input functions.  `  
ValidateApp验证所提供的图形将运行且不缺少任何依赖项。此方法不调用实际的输入函数。  
```
func ValidateApp(opts ...Option) error {
	opts = append(opts, validate(true))
	app := New(opts...)

	return app.Err()
}
```

### func VisualizeError
```func VisualizeError(err error) (string, error)  ```  
`VisualizeError returns the visualization of the error if available.  `  
VisualizeError返回错误的可视化（如果可用）。  
猜想就是上面的ValidateApp函数返回error，然后就可以把这个error输入到VisualizeError。
### type Annotated
```
type Annotated struct {
	// If specified, this will be used as the name for all non-error values returned
	// by the constructor. For more information on named values, see the documentation
	// for the fx.Out type.
	//如果指定Name参数，它将用作构造函数返回的所有非错误值的名称。有关命名值的更多信息，请参见fx.Out类型的文档。
	// A name option may not be provided if a group option is provided.
	// 如果提供了组选项，则可能不提供名称选项。
	Name string

	// If specified, this will be used as the group name for all non-error values returned
	// by the constructor. For more information on value groups, see the package documentation.
	// 如果指定Group参数，它将用作构造函数返回的所有非错误值的组名。 有关值组的更多信息，请参见包文件。
	// A group option may not be provided if a name option is provided.
	// 如果提供了名称选项，则可能不提供组选项。
	// Similar to group tags, the group name may be followed by a `,flatten`
	// option to indicate that each element in the slice returned by the
	// constructor should be injected into the value group individually.
	// 与组标签类似，组名后可以带有`，flatten`。选项 。指示应将构造方法返回的切片中的每个元素分别注入值组。
	Group string

	// Target is the constructor or value being annotated with fx.Annotated.
	// Target参数是用fx.Annotated注释的构造函数或值。
	Target interface{}
}
```  
`Annotated annotates a constructor provided to Fx with additional options.  `  
带注解的Fx提供给带有其他选项的构造函数。  
For example,  
```
func NewReadOnlyConnection(...) (*Connection, error)

fx.Provide(fx.Annotated{
  Name: "ro",
  Target: NewReadOnlyConnection,
})
```
Is equivalent to,  
```
type result struct {
  fx.Out

  Connection *Connection `name:"ro"`
}

fx.Provide(func(...) (Result, error) {
  conn, err := NewReadOnlyConnection(...)
  return Result{Connection: conn}, err
})
```
`Annotated cannot be used with constructors which produce fx.Out objects.  `  
带注解的不能与产生fx.Out对象的构造函数一起使用。  

`When used with fx.Supply, the target is a value rather than a constructor function.  `  
与fx.Supply一起使用时，目标是值而不是构造函数。  

### func (Annotated) String
```func (a Annotated) String() string```

### type App
```
type App struct {
	// contains filtered or unexported fields
}
```
```
func New(opts ...Option) *App //New函数会返回一个App指针
```
`An App is a modular application built around dependency injection. Most users will only need to use the New constructor and the all-in-one Run convenience method. In more unusual cases, users may need to use the Err, Start, Done, and Stop methods by hand instead of relying on Run.  `  
App是一个围绕依赖项注入而构建的模块化应用程序。 大多数用户只需要使用fx.New构造函数和多合一App.Run便捷方法。  
在更不常见的情况下，用户可能需要手动使用App.Err，App.Start，App.Done和App.Stop方法，而不是依赖于App.Run。  

`New creates and initializes an App. All applications begin with a constructor for the Lifecycle type already registered.  `  
fx.New创建并初始化App。所有应用程序都以，已注册的生命周期类型的构造函数开头。  

`In addition to that built-in functionality, users typically pass a handful of Provide options and one or more Invoke options.   `  
除了内置的功能之外，用户通常会传递一些fx.Provide选项和一个或多个fx.Invoke选项。  

`The Provide options teach the application how to instantiate a variety of types, and the Invoke options describe how to initialize the application.  `  
fx.Provide选项教应用程序**如何实例化各种类型**，Invoke选项描述**如何初始化应用程序**。  

`Once , all the [invocations] (and any required constructors) have been called, [New] returns and the application is ready to be started using [Run] or [Start].  `  
一旦调用了所有的[invocations]（和任何必需的构造函数），[fx.New]返回，应用程序就可以使用[App.Run]或[App.Start]启动了。  
`On startup, it executes any [OnStart] hooks registered with its Lifecycle. [OnStart] hooks are executed one at a time, in order, and must all complete within a configurable deadline (by default, 15 seconds).   `  
在启动时，它将执行在其生命周期中注册的任何[OnStart]钩子。钩子在最后期限内完成（默认情况下，必须在15秒内完成）。    
`For details on the order in which OnStart hooks are executed, see the documentation for the Start method.  `  
有关OnStart钩子执行顺序的详细信息，请参阅Start方法的文档。    

`At this point, the application has successfully started up. If started via [Run], it will continue operating until it receives a shutdown signal from [Done] (see the Done documentation for details); if started explicitly via [Start], it will operate until the user calls [Stop].  `  
此时，应用程序已成功启动。如果通过[App.Run]启动，它将继续运行，直到从[App.Done]接收到关闭信号（有关详细信息，请参阅Done文档）；如果通过[App.Start]显式启动，它将运行到用户调用[App.Stop]。  
 `On shutdown, OnStop hooks execute one at a time, in reverse order, and must all complete within a configurable deadline (again, 15 seconds by default).  `  
在关闭时，OnStop钩子以相反的顺序一次执行一个，并且必须在可配置的截止日期（默认情况下，也是15秒）内全部完成。

### func New
```func New(opts ...Option) *App```   
`[New] creates and initializes an [App], immediately executing any functions registered via Invoke options.  `  
[fx.New]创建并初始化[fx.App]，立即执行通过fx.Invoke选项注册的任何函数。  
 `See the documentation of the [App] struct for details on the application's initialization, startup, and shutdown logic.  `  
有关应用程序的初始化、启动和关闭逻辑的详细信息，请参阅[App]结构的文档。  
```go
app := fx.New(//fx.New函数的功能就是(1)创建并且初始化app
	fx.Provide(
			NewMyConstruct,
			NewHandler,
			NewMux,
			NewLogger,
		),
		//(2)立即执行fx.Invoke注册的任何函数
		fx.Invoke(invokeNothingUse, invokeRegister, invokeAnotherFunc, invokeUseMyconstruct),
	)
```

### func (*App) Done
```func (app *App) Done() <-chan os.Signal```  

`Done] returns a channel of signals , to block on after starting the application. Applications listen for the SIGINT and SIGTERM signals; during development, users can send the application SIGTERM by pressing Ctrl-C in the same terminal as the running process.`
[App.Done]返回一个信号通道，以在启动应用程序后阻塞。 应用程序监听SIGINT和SIGTERM信号。 在开发过程中，用户可以通过在运行进程的同一终端上按Ctrl-C来发送应用程序SIGTERM。
`lternatively, a signal can be broadcast to all done channels manually by using the Shutdown functionality (see the Shutdowner documentation for details).`
或者，可以使用“Shutdown”功能将信号手动广播到所有已完成的频道（有关详细信息，请参见“关机”文档）。

### func (*App) Err 
```func (app *App) Err() error```
`Err returns any error encountered during New's initialization. See the documentation of the New method for details, but typical errors include missing constructors, circular dependencies, constructor errors, and invocation errors.`
App.Err返回New初始化期间遇到的任何错误。 有关详细信息，请参见New方法的文档，但典型的错误包括缺少构造函数，循环依赖项，构造函数错误和调用错误。
`Most users won't need to use this method, since both Run and Start short-circuit if initialization failed.`
大多数用户不需要使用此方法，因为如果初始化失败，则App.Start和Start.Run会短路。

### func (*App) Run 
```
func (app *App) Run() {
	app.run(app.Done())
}
func (app *App) run(done <-chan os.Signal) {
}
```
`Run starts the application, blocks on the signals channel, and then gracefully shuts the application down. It uses DefaultTimeout to set a deadline for application startup and shutdown, unless the user has configured different timeouts with the StartTimeout or StopTimeout options. It's designed to make typical applications simple to run.`
App.Run启动应用程序，在信号通道上阻塞，然后正常关闭应用程序。 除非用户使用App.StartTimeout或App.StopTimeout选项配置了不同的超时，否则它将使用App.DefaultTimeout设置应用程序启动和关闭的期限。 它旨在使典型应用程序易于运行。
`However, all of Run's functionality is implemented in terms of the exported Start, Done, and Stop methods. Applications with more specialized needs can use those methods directly instead of relying on Run.`
但是，App.Run的所有功能都是通过导出的App.Start，App.Done和App.Stop方法实现的。 具有更特殊需求的应用程序可以直接使用这些方法，而不必依赖App.Run。

### func (*App) Start
```func (app *App) Start(ctx context.Context) error```

`[App.Start] kicks off all long-running goroutines, like network servers or message queue consumers. It does this by interacting with the application's Lifecycle.`
[App.Start]启动所有长时间运行的goroutine，例如网络服务器或消息队列使用者。 它通过与应用程序的生命周期进行交互来实现。
`By taking a dependency on the Lifecycle type, some of the user-supplied functions called during initialization may have registered start and stop hooks. Because initialization calls constructors serially and in dependency order, hooks are naturally registered in dependency order too.`
通过依赖生命周期类型，初始化期间调用的某些用户提供的函数可能已注册了start和stop钩子函数。 因为初始化顺序根据依赖关系顺序调用构造函数，所以挂钩也自然会以依赖关系顺序进行注册。
`[fx.Start] executes all [OnStart] hooks registered with the application's Lifecycle, one at a time and in order. This ensures that each constructor's start hooks aren't executed until all its dependencies' start hooks complete. If any of the start hooks return an error, [App.Start ]short-circuits, calls [App.Stop], and returns the inciting error.`
[fx.Start]一次并依次执行在应用程序的**生命周期中注册**的所有[OnStart]挂钩。 **这样可以确保在所有依赖项的启动挂钩完成之前，不会执行每个构造函数的启动挂钩。** 如果任何启动挂钩返回错误，则[App.Start]短路，调用[App.Stop]，并返回引发错误。
`Note that [fx.Start] short-circuits immediately if the [fx.New] constructor encountered any errors in application initialization.`
请注意，如果[fx.New]构造函数在应用程序初始化中遇到任何错误，则[fx.Start]会立即短路。

### func (*App) StartTimeout 
```func (app *App) StartTimeout() time.Duration```
`App.StartTimeout returns the configured startup timeout. Apps default to using App.DefaultTimeout, but users can configure this behavior using the App.StartTimeout option.`
App.StartTimeout返回配置的启动超时。 应用默认使用App.DefaultTimeout，但是用户可以使用App.StartTimeout选项配置此行为。

### func (*App) Stop 
```func (app *App) Stop(ctx context.Context) error```
`Stop gracefully stops the application. It executes any registered OnStop hooks in reverse order, so that each constructor's stop hooks are called before its dependencies' stop hooks.`
App.Stop优雅地停止应用程序。 它以相反的顺序执行所有已注册的OnStop挂钩，因此在依赖项的停止挂钩之前调用每个构造函数的停止挂钩。
`If the application didn't start cleanly, only hooks whose OnStart phase was called are executed. However, all those hooks are executed, even if some fail.`
如果应用程序无法正常启动，则仅执行其OnStart阶段被调用的钩子。 但是，即使所有这些钩子都失败了，它们也会被执行。
### func (*App) StopTimeout 
```func (app *App) StopTimeout() time.Duration```
`App.StopTimeout returns the configured shutdown timeout. Apps default to using App.DefaultTimeout, but users can configure this behavior using the StopTimeout option.`
App.StopTimeout返回配置的关闭超时。 应用默认使用App.DefaultTimeout，但是用户可以使用StopTimeout选项配置此行为。

### type DotGraph 
```type DotGraph string```
`DotGraph contains a DOT language visualization of the dependency graph in an Fx application. It is provided in the container by default at initialization. On failure to build the dependency graph, it is attached to the error and if possible, colorized to highlight the root cause of the failure.`
DotGraph包含Fx应用程序中依赖图的DOT语言可视化。 默认情况下在初始化时在容器中提供它。 在无法建立依赖关系图时，它会附加到[error]，并在可能的情况下以彩色突出显示失败的根本原因。

### type ErrorHandler
```
type ErrorHandler interface {
	HandleError(error)
}
```
`ErrorHandler handles Fx application startup errors.`
ErrorHandler处理Fx应用程序启动错误。
### type Hook 
```
type Hook struct {
	OnStart func(context.Context) error
	OnStop  func(context.Context) error
}
```
`A Hook is a pair of start and stop callbacks, either of which can be nil. If a Hook's OnStart callback isn't executed (because a previous OnStart failure short-circuited application startup), its OnStop callback won't be executed.`  
[Hook]是一对[start]和[stop]回调，其中两个都可以为nil。 如果未执行Hook的OnStart回调（由于先前的OnStart故障使应用程序启动短路），则不会执行其OnStop回调。
### type In 
```
type In struct{ dig.In }
```
`In can be embedded in a constructor's parameter struct to take advantage of advanced dependency injection features.`  
[In struct]可以嵌入到构造函数的参数struct中，以利用高级依赖注入特性。  
`Modules should take a single parameter struct that embeds an In in order to provide a forward-compatible API: since adding fields to a struct is backward-compatible, modules can then add optional dependencies in minor releases.`  

### Parameter Structs
`Fx constructors declare their dependencies as function parameters. This can quickly become unreadable if the constructor has a lot of dependencies.`  
Fx构造函数将它们的依赖项声明为函数参数。如果构造函数有很多依赖项，这可能很快变得不可读。  
```
func NewHandler(users *UserGateway, comments *CommentGateway, posts *PostGateway, votes *VoteGateway, authz *AuthZGateway) *Handler {
  // ...
}
```  
`To improve the readability of constructors like this, create a struct that lists all the dependencies as fields and change the function to accept that struct instead. The new struct is called a parameter struct.`
为了提高这样的构造函数的可读性，请创建一个将所有依赖项列为字段的结构，然后更改[function]以接受该结构。 新的结构称为参数结构。
`Fx has first class support for [parameter structs]: any struct embedding fx.`  
Fx对[parameter structs]具有一流的支持：任何嵌入fx的结构。  
`[In] gets treated as a [parameter struct], so the individual fields in the struct are supplied via dependency injection. Using a [parameter struct], we can make the constructor above much more readable:`  
[In]被视为[parameter struct]，因此该结构中的各个字段通过依赖项注入来提供。 使用[parameter struct]，我们可以使上面的构造函数更具可读性：
```go
type HandlerParams struct {
  fx.In

  Users    *UserGateway
  Comments *CommentGateway
  Posts    *PostGateway
  Votes    *VoteGateway
  AuthZ    *AuthZGateway
}

func NewHandler(p HandlerParams) *Handler {
  // ...
}
```  
`Though it's rarely a good idea, constructors can receive any combination of [parameter structs] and [parameters.]`  
尽管这不是一个好主意，但构造函数可以接收[parameter structs]和[parameters]的任意组合。  
```
func NewHandler(p HandlerParams, l *log.Logger) *Handler {
  // ...
}
```  
### Optional Dependencies
Constructors often have soft dependencies on some types: 
构造函数通常对某些类型具有软依赖性：  
if those types are missing, they can operate in a degraded state. Fx supports optional dependencies via the \`optional:"true"\` tag to fields on [parameter structs].    
如果缺少这些类型，则它们可以降级状态运行。 Fx通过对[parameter structs]上的字段的`optional：“ true”`标签支持可选的依赖关系。  
```
type UserGatewayParams struct {
  fx.In

  Conn  *sql.DB
  Cache *redis.Client `optional:"true"`
}
```  
`If an optional field isn't available in the container, the constructor receives the field's zero value.`  
如果容器中没有可选字段，则构造函数将接收该字段的零值。
```
func NewUserGateway(p UserGatewayParams, log *log.Logger) (*UserGateway, error) {
  if p.Cache == nil {
    log.Print("Caching disabled")
  }
  // ...
}
```
`Constructors that declare optional dependencies MUST gracefully handle situations in which those dependencies are absent.`  
声明可选依赖项的构造函数务必妥善处理那些不存在依赖项的情况  
`The optional tag also allows adding new dependencies without breaking existing consumers of the constructor.`  
可选标签还允许添加新的依赖项，而不会破坏构造函数的现有使用者  
### Named Values
`Some use cases require the application container to hold multiple values of the same type. For details on producing named values, see the documentation for the Out type.`  
某些用例需要[应用程序容器]保存相同类型的多个值。有关生成命名值的详细信息，请参见Out类型的文档。  
`Fx allows functions to consume named values via the \`name:".."\` tag on parameter structs. Note that both the name AND type of the fields on the parameter struct must match the corresponding result struct.`  
Fx允许函数通过[parameter structs]上的`name:".."`标记使用命名值。 请注意，[parameter struct]上字段的名称和类型都必须与相应的结果结构匹配  
```
type GatewayParams struct {
  fx.In

  WriteToConn  *sql.DB `name:"rw"`
  ReadFromConn *sql.DB `name:"ro"`
}
```
`The name tag may be combined with the optional tag to declare the dependency optional.`  
名称标签可以与可选标签结合使用，以声明依赖项为可选。  
```
type GatewayParams struct {
  fx.In

  WriteToConn  *sql.DB `name:"rw"`
  ReadFromConn *sql.DB `name:"ro" optional:"true"`
}

func NewCommentGateway(p GatewayParams, log *log.Logger) (*CommentGateway, error) {
  if p.ReadFromConn == nil {
    log.Print("Warning: Using RW connection for reads")
    p.ReadFromConn = p.WriteToConn
  }
  // ...
}
```
### Value Groups
`To make it easier to produce and consume many values of the same type, Fx supports named, unordered collections called value groups. For details on producing value groups, see the documentation for the Out type.`   
为了更容易产生和使用许多相同类型的值，Fx支持命名的无序集合，称为值组。 有关产生值组的详细信息，请参见Out类型的文档。     
Functions can depend on a value group by requesting a slice tagged with `group:".."`. 
This will execute all constructors that provide a value to that group in an unspecified order, then collect all the results into a single slice. 
Keep in mind that this makes the types of the parameter and result struct fields different: if a group of constructors each returns type T, parameter structs consuming the group must use a field of type []T.
通过请求带有`group：“ ..”`标签的切片，函数可以依赖于值组。这将执行所有以未指定顺序向该组提供值的构造函数，然后将所有结果收集到单个切片中。请记住，这会使参数和结果结构字段的类型不同：如果一组构造函数各自返回类型T，则使用该组的参数结构必须使用类型为[] T的字段。  
```
type ServerParams struct {
  fx.In

  Handlers []Handler `group:"server"`
}

func NewServer(p ServerParams) *Server {
  server := newServer()
  for _, h := range p.Handlers {
    server.Register(h)
  }
  return server
}
```
`Note that values in a value group are unordered. Fx makes no guarantees about the order in which these values will be produced.`  
请注意，值组中的值是无序的。 Fx不保证这些值的生成顺序。  
### type Lifecycle 
```
type Lifecycle interface {
	Append(Hook)
}
```
`Lifecycle allows constructors to register callbacks that are executed on application start and stop. See the documentation for App for details on Fx applications' initialization, startup, and shutdown logic.`
生命周期允许**构造函数**注册在**应用程序**启动和停止时执行的回调。 有关Fx应用程序的初始化，启动和关闭逻辑的详细信息，请参阅App的文档。

### type Option
```
type Option interface {
	fmt.Stringer
	// contains filtered or unexported methods
}
```
`An Option configures an App using the functional options paradigm popularized by Rob Pike. If you're unfamiliar with this style, see https://commandcenter.blogspot.com/2014/01/self-referential-functions-and-design.html.`
[Option]使用Rob Pike流行的功能选项范例配置应用程序。
如果您不熟悉这种风格，请参阅https://commandcenter.blogspot.com/2014/01/self-referential-functions-and-design.html

### func Error 
```
func Error(errs ...error) Option
```
`Error registers any number of errors with the application to short-circuit startup. If more than one error is given, the errors are combined into a single error.`
Error会在应用程序中注册任何数量的错误，以缩短启动时间。 如果给出多个错误，则将这些错误合并为一个错误。
`Similar to [invocations], [errors] are applied in order. All [Provide] and [Invoke] options registered before or after an [Error] option will not be applied.`
与[Invoke]相似，[errors]按顺序应用。 在[Error]选项之前或之后注册的所有[Provide]和[Invoke]选项均不会应用。
```
newHTTPServer := func() fx.Option {
	port := os.Getenv("PORT")
	if port == "" {
		return fx.Error(errors.New("$PORT is not set"))//生成一个错误模式
	}
	return fx.Provide(&http.Server{
		Addr: fmt.Sprintf(":%s", port),
	})
}

app := fx.New(
	newHTTPServer(),
	fx.Invoke(func(s *http.Server) error { return s.ListenAndServe() }),
)

fmt.Println(app.Err()) //$PORT is not set
```
### func ErrorHook
```
func ErrorHook(funcs ...ErrorHandler) Option
```  
`ErrorHook registers error handlers that implement error handling functions. They are executed on invoke failures. Passing multiple ErrorHandlers appends the new handlers to the application's existing list.  `  
ErrorHook注册实现错误处理功能的错误处理程序。 它们在调用失败时执行。 传递多个ErrorHandlers会将新的处理程序追加到应用程序的现有列表中。

### func Extract 
```
func Extract(target interface{}) Option
```
Extract fills the given struct with values from the dependency injection container on application initialization. The target MUST be a pointer to a struct. Only exported fields will be filled.

Extract will be deprecated soon: use Populate instead, which doesn't require defining a container struct.

### func Invoke
```
func Invoke(funcs ...interface{}) Option
```
Invoke registers functions that are executed eagerly on application start. Arguments for these invocations are built using the constructors registered by Provide. Passing multiple Invoke options appends the new invocations to the application's existing list.  
fx.Invoke注册在应用程序启动时急切执行的功能。 这些调用的参数是使用fx.Provide注册的构造函数构建的。 传递多个fx.Invoke选项可将新的调用附加到应用程序的现有列表中。  
Unlike constructors, invocations are always executed, and they're always run in order. Invocations may have any number of returned values. If the final returned object is an error, it's assumed to be a success indicator. All other returned values are discarded.  
与构造函数不同，Invoke始终执行，并且始终按顺序运行。 Invoke可以具有任意数量的返回值。 如果最后返回的对象是错误，则假定它是成功指示符。 所有其他返回值都将被丢弃。  
Typically, invoked functions take a handful of high-level objects (whose constructors depend on lower-level objects) and introduce them to each other. This kick-starts the application by forcing it to instantiate a variety of types.  
通常，invoked函数会使用少量高级对象（其构造函数依赖于低级对象）并将它们彼此引入。 通过强制实例化各种类型来启动应用程序。   
To see an invocation in use, read through the package-level example. For advanced features, including optional parameters and named instances, see the documentation of the In and Out types.  
要查看正在使用的[invocation]，请通读包级示例。 有关高级功能（包括可选参数和命名实例），请参见In和Out类型的文档。  

### func Logger 
```
func Logger(p Printer) Option
```
Logger redirects the application's log output to the provided printer.
Logger将应用程序的日志输出重定向到提供的打印机。

### func Options 
```
func Options(opts ...Option) Option
```
Options converts a collection of Options into a single Option. This allows packages to bundle sophisticated functionality into easy-to-use Fx modules. For example, a logging package might export a simple option like this:  
Options 将选项的集合转换为单个选项。 这使程序包可以将复杂的功能捆绑到易于使用的Fx模块中。 例如，日志记录程序包可能会导出一个简单的选项，如下所示： 
```
package logging

var Module = fx.Provide(func() *log.Logger {
  return log.New(os.Stdout, "", 0)
})
```
A shared all-in-one microservice package could then use Options to bundle logging with similar metrics, tracing, and gRPC modules:

### type Out
```
type Out struct{ dig.Out }
```
`Out is the inverse of In: it can be embedded in result structs to take advantage of advanced features.`
Out是In的逆功能：它可以嵌入到结果结构中以利用高级功能。   
`Modules should return a single result struct that embeds an Out in order to provide a forward-compatible API: since adding fields to a struct is backward-compatible, minor releases can provide additional types.`  
模块应返回嵌入Out的单个结果结构，以提供前向兼容的API：由于向结构中添加字段是向后兼容的，因此次要发行版可以提供其他类型。  
### Result Structs
`Result structs are the inverse of parameter structs (discussed in the In documentation). These structs represent multiple outputs from a single function as fields. Fx treats all structs embedding fx.Out as result structs, so other constructors can rely on the result struct's fields directly.`  
结果结构与参数结构相反（在In文档中讨论）。这些结构将单个函数的多个输出表示为字段。Fx将嵌入fx.Out的所有结构都视为结果结构，因此其他构造函数可以直接依赖结果结构的字段。  
`Without result structs, we sometimes have function definitions like this:`
没有结果结构，有时我们会有这样的函数定义
```
func SetupGateways(conn *sql.DB) (*UserGateway, *CommentGateway, *PostGateway, error) {
  // ...
}
```
With result structs, we can make this both more readable and easier to modify in the future:  
使用结果结构，我们可以使其更易读，将来更容易修改：  
```
type Gateways struct {
  fx.Out

  Users    *UserGateway
  Comments *CommentGateway
  Posts    *PostGateway
}

func SetupGateways(conn *sql.DB) (Gateways, error) {
  // ...
}
```
### Named Values
`Some use cases require the application container to hold multiple values of the same type. For details on consuming named values, see the documentation for the In type.`
一些用例要求应用程序容器包含相同类型的多个值。 有关使用命名值的详细信息，请参见In类型的文档。
`A constructor that produces a result struct can tag any field with `name:".."` to have the corresponding value added to the graph under the specified name. An application may contain at most one unnamed value of a given type, but may contain any number of named values of the same type.`
生成结果结构的构造函数可以使用“ name：” ..”标记任何字段，以使用指定的名称将对应的值添加到图形中。一个应用程序最多可以包含一个给定类型的未命名值，但可以包含任意数量的相同类型的命名值。
```
type ConnectionResult struct {
  fx.Out

  ReadWrite *sql.DB `name:"rw"`
  ReadOnly  *sql.DB `name:"ro"`
}

func ConnectToDatabase(...) (ConnectionResult, error) {
  // ...
  return ConnectionResult{ReadWrite: rw, ReadOnly:  ro}, nil
}
```
### Value Groups
`To make it easier to produce and consume many values of the same type, Fx supports named, unordered collections called value groups. For details on consuming value groups, see the documentation for the In type.`   
为了更容易产生和使用许多相同类型的值，Fx支持命名的无序集合，称为值组。 有关使用值组的详细信息，请参见[In]类型的文档。  

`Constructors can send values into value groups by returning a result struct tagged with `group:".."`.`  
构造函数可以通过返回标记为“ group：” ..”的结果结构将值发送到值组中。  
```
type HandlerResult struct {
  fx.Out

  Handler Handler `group:"server"`
}

func NewHelloHandler() HandlerResult {
  // ...
}

func NewEchoHandler() HandlerResult {
  // ...
}
```
`Any number of constructors may provide values to this named collection, but the ordering of the final collection is unspecified. Keep in mind that value groups require parameter and result structs to use fields with different types: if a group of constructors each returns type T, parameter structs consuming the group must use a field of type []T.`  
任何数量的构造函数都可以为该命名的集合提供值，但最终集合的顺序未指定。 请记住，值组要求参数和结果结构使用不同类型的字段：如果一组构造函数各自返回类型T，则使用该组的参数结构必须使用类型为[] T的字段。  
`To provide multiple values for a group from a result struct, produce a slice and use the `,flatten` option on the group tag. This indicates that each element in the slice should be injected into the group individually.`  
要从结果结构中为一个组提供多个值，请产生一个切片并在组标记上使用`，flatten`选项。 这表明切片中的每个元素应单独注入到组中。  
```
type IntResult struct {
  fx.Out

  Handler []int `group:"server"`         // Consume as [][]int
  Handler []int `group:"server,flatten"` // Consume as []int
}
```

### type Printer
```
type Printer interface {
	Printf(string, ...interface{})
}
```
Printer is the interface required by Fx's logging backend. It's implemented by most loggers, including the one bundled with the standard library.
Printer是Fx的日志记录后端所需的接口。 它由大多数logger实现，包括与标准库捆绑在一起的一种。

### type ShutdownOption 
```
type ShutdownOption interface {
	// contains filtered or unexported methods
}
``` 
ShutdownOption provides a way to configure properties of the shutdown process. Currently, no options have been implemented.  
ShutdownOption提供了一种配置关机过程属性的方法。 当前，尚未实施任何选项。   

### type Shutdowner 
```
type Shutdowner interface {
	Shutdown(...ShutdownOption) error
}
```
Shutdowner provides a method that can manually trigger the shutdown of the application by sending a signal to all open Done channels. Shutdowner works on applications using Run as well as Start, Done, and Stop. The Shutdowner is provided to all Fx applications.
Shutdowner提供了一种方法，该方法可以通过向所有打开的[Done]通道发送信号来手动触发应用程序的关闭。 Shutdowner适用于使用[Run]以及[Start]，[Done]和[Stop]的应用程序。 Shutdowner提供给所有Fx应用程序。


```go
package main

import (
	"context"
	"fmt"
	"log"
	"net/http"
	"time"

	"go.uber.org/fx"
)

// 这里把main函数放到最前面，可以清晰的先了解代码调用方法，具体函数定义，自行跳跃过去查看
func main() {

	// 整个fx包执行的顺序是
	// 1. 先执行fx.Invoke中的函数列表，按顺序一个一个执行
	// 2. fx.Provide中构造函数，在Invoke需要的时候，再去执行
	// 执行Invoke中的函数时，当前执行的函数传入参数如果用到的变量，则先调用其构造函数

	// 这里构造函数构造出来的变量不需要明显的进行定义，会自动传给invoke函数。（也就是说fx.Provider中的构造函数执行完成了，生成了变量，这些变量会自动的传递给invoke函数，而不用你自己手动传递）

	// 比如invokeNothingUse 这里没有任何传入参数，则在它之前不执行任何构造函数。 
	//
	// Register执行时，需要mux *http.ServeMux, h http.Handler, logger *log.Logger 三个传入参数，则执行对应的三个构造函数
	// 但是在执行 NewHandler构造函数时，需要logger，则在其之前执行NewLogger
	//
	// invokeUseMyconstruct 执行时，需要先执行 NewMyConstruct

	// 至于在fx.Lifecycle 中注册的Onstart OnStop 函数，是在app start 之后，按构造函数的顺序来执行，stop时，按相反顺序执行
	app := fx.New(

		// 一系列构造函数
		fx.Provide(
			NewMyConstruct,
			NewHandler,
			NewMux,
			NewLogger,
		),

		// 构造函数执行完后，执行初始化函数
		fx.Invoke(invokeNothingUse, invokeRegister, invokeAnotherFunc, invokeUseMyconstruct),
	)

	startCtx, cancel := context.WithTimeout(context.Background(), 15*time.Second)
	defer cancel()
	if err := app.Start(startCtx); err != nil {
		log.Fatal(err)
	}

	http.Get("http://localhost:8080/")

	stopCtx, cancel := context.WithTimeout(context.Background(), 15*time.Second)
	defer cancel()
	if err := app.Stop(stopCtx); err != nil {
		log.Fatal(err)
	}

}

// *log.Logger 类型对象的构造函数 （注意：这里指针与非指针类型是严格区分的）
func NewLogger(lc fx.Lifecycle) *log.Logger {
	logger := log.New(os.Stdout, "" /* prefix */, 0 /* flags */)
	logger.Print("Executing NewLogger.")

	lc.Append(fx.Hook{
		OnStart: func(i context.Context) error {
			logger.Println("logger onstart..")
			return nil
		},
		OnStop: func(i context.Context) error {
			logger.Println("logger onstop..")
			return nil
		},
	})
	return logger
}

// http.Handler 类型对象的构造函数，它输入参数中需要*log.Logger类型，所以在它执行之前，先执行NewLogger
func NewHandler(lc fx.Lifecycle, logger *log.Logger) (http.Handler, error) {
	logger.Print("Executing NewHandler.")
	lc.Append(fx.Hook{
		OnStart: func(i context.Context) error {
			logger.Println("handler onstart..")
			return nil
		},
		OnStop: func(i context.Context) error {
			logger.Println("handler onstop..")
			return nil
		},
	})

	return http.HandlerFunc(func(http.ResponseWriter, *http.Request) {
		logger.Print("Got a request.")
	}), nil
}

// *http.ServeMux 类型对象的构造函数，它输入参数中需要*log.Logger类型，所以在它执行之前，先执行NewLogger
func NewMux(lc fx.Lifecycle, logger *log.Logger) *http.ServeMux {
	logger.Print("Executing NewMux.")
	mux := http.NewServeMux()
	server := &http.Server{
		Addr:    ":8080",
		Handler: mux,
	}
	lc.Append(fx.Hook{
		OnStart: func(context.Context) error {
			logger.Print("Starting HTTP server.")
			go server.ListenAndServe()
			return nil
		},
		OnStop: func(ctx context.Context) error {
			logger.Print("Stopping HTTP server.")
			return server.Shutdown(ctx)
		},
	})
	return mux
}

// 自定义类型
type mystruct struct{}

// mystruct 构造函数
func NewMyConstruct(logger *log.Logger) mystruct {
	logger.Println("Executing NewMyConstruct.")
	return mystruct{}
}

// invokeUseMyconstruct 是invoke函数，在其执行之前，需要执行 NewMyConstruct
func invokeUseMyconstruct(logger *log.Logger, c mystruct) {
	logger.Println("invokeUseMyconstruct..")
}

func invokeRegister(mux *http.ServeMux, h http.Handler, logger *log.Logger) {
	logger.Println("invokeRegiste...")
	mux.Handle("/", h)
}

func invokeAnotherFunc(logger *log.Logger) {
	logger.Println("invokeAnotherFunc...")
}

// 这个invoke函数，不依赖任何输入变量，所以不需要执行任何构造函数
func invokeNothingUse() {
	fmt.Println("invokeNothingUse...")
}

[root@LIN-6A14041F8B1 main]# go run main.go 
2020/08/10 09:53:05 [Fx] PROVIDE	main.mystruct <= main.NewMyConstruct()
2020/08/10 09:53:05 [Fx] PROVIDE	http.Handler <= main.NewHandler()
2020/08/10 09:53:05 [Fx] PROVIDE	*http.ServeMux <= main.NewMux()
2020/08/10 09:53:05 [Fx] PROVIDE	*log.Logger <= main.NewLogger()
2020/08/10 09:53:05 [Fx] PROVIDE	fx.Lifecycle <= go.uber.org/fx.New.func1()
2020/08/10 09:53:05 [Fx] PROVIDE	fx.Shutdowner <= go.uber.org/fx.(*App).shutdowner-fm()
2020/08/10 09:53:05 [Fx] PROVIDE	fx.DotGraph <= go.uber.org/fx.(*App).dotGraph-fm()
2020/08/10 09:53:05 [Fx] INVOKE		main.invokeNothingUse()
invokeNothingUse...
2020/08/10 09:53:05 [Fx] INVOKE		main.invokeRegister()
Executing NewLogger.
Executing NewMux.
Executing NewHandler.
invokeRegiste...
2020/08/10 09:53:05 [Fx] INVOKE		main.invokeAnotherFunc()
invokeAnotherFunc...
2020/08/10 09:53:05 [Fx] INVOKE		main.invokeUseMyconstruct()
Executing NewMyConstruct.
invokeUseMyconstruct..
2020/08/10 09:53:05 [Fx] START		main.NewLogger()
logger onstart..
2020/08/10 09:53:05 [Fx] START		main.NewMux()
Starting HTTP server.
2020/08/10 09:53:05 [Fx] START		main.NewHandler()
handler onstart..
2020/08/10 09:53:05 [Fx] RUNNING
Got a request.
2020/08/10 09:53:05 [Fx] STOP		main.NewHandler()
handler onstop..
2020/08/10 09:53:05 [Fx] STOP		main.NewMux()
Stopping HTTP server.
2020/08/10 09:53:05 [Fx] STOP		main.NewLogger()
logger onstop..
[root@LIN-6A14041F8B1 main]# 

```


## 参考
- [go fx官方文档](https://pkg.go.dev/go.uber.org/fx?tab=doc)
