## 一、服务器性能问题的引入

​    假设我们使用`LAMP`搭建了一个网站，并发状态的请求有`200`个,而其中的 `50`个请求是 `dynamic（动态的）`那么我们估算它需要多少资源，假设我们的`apache`工作在`prefork`模式下，大概每一个进程所占用的内存空间应该有`2M`，涉及到的动态进程，一个动态进程内存空间大概是`10M`左右。`500M+150*2M`所以大致需要`800M`的内存，这`50`个动态进程，每个在执行的时候可能和本地的`mysql`进行交互，`mysql`是`cup`密集型的操作，而且进程切换本身也需要`cpu`，所以我们配置了一个2个`cpu`和`4g`内存，另外假设`200`个请求同时到达，那么我们的网卡要开始进行处理，还是需要`cpu` 。因为到达网卡上的`http`请求，是通过硬件网卡上来的，所以首先要到达内核空间，但是我们的`web`服务器是运行在用户空间的，所以需要内核空间进行一定的处理传递给用户空间的`web`服务器。

   因为有`200`个并发请求，那么意味着随时随地可能有`200`个`IO`。而几乎每一个`IO`都需要有`CPU`的参与来执行的。而且每个用户的请求数据都位于磁盘上。磁盘上的数据只有被操作系统内核载入到内核空间才能通过`web`服务器经过网卡发送给用户，所以`web`请求的背后，会涉及到大量的网络`IO`和磁盘`IO`。而这些不可避免的会影响我们网络服务器的性能的。假如网站越来越受到环境，并发请求变成了`1000`，那么其中有动态请求是`200`。什么是动态请求，什么是静态请求，比如请求`html，css，img`等等这些都是静态请求，需要服务器程序运行的就是动态请求。动态请求的执行速度很慢的，比静态请求慢。那么这个时候需要的资源就是`800*2+200*10`，那么这个时候资源开始吃紧了。我们还是两个`cpu`但是我们有`1000`个进程，所以一个`cpu`上会有500个进程进行切换，那么这个时候光进行切换，就需要很多的资源，所以我们的服务器应该相当的吃力了。

​    还有假如我们的带宽上线只有`400`个进程，那么另外的`600`个都需要进行排队。这个时候用户体验就会非常的差。研究发现一个网站打开时间超过`3s`就会流失`60%`的用户。



## 二、解决方法

（1）`Scala on向上扩展`   就是换服务器，原来是`4g`内存，2个`cpu`，那么我们换成`16g`内存，`8`个`cpu`。所以通过调换一台有这更强处理能力的服务器，这个就是`Scala on`。但是一般来说尽管变成了`16g`内存和`8`个`cpu`。但是我们带来的性能并不是原来的`4`倍。这个不是线性的，而是类似于sin(x)的走到顶峰就会下降。`8`个cpu会产生争夺，需要仲裁。仲裁本身还需要资源，这个需要的资源代价也很大。另外硬件的价格非常的贵。而且当请求变成`10万`，你能找到这样的服务器吗？

（2）`Scala out向外扩展`

一台服务器如果能处理`200`那么我就多加上几台，这样不就能处理`1000`了吗？但是问题来了，我们怎么能将用户的请求分到三台不同的服务器上。所以引入了负载均衡！

比如使用`DNS`的`A`记录有如下：

```shell
www.baidu.com.cn     IN     A   172.100.120.1
www.baidu.com.cn     IN     A   172.100.120.2
www.baidu.com.cn     IN     A   172.100.120.3
```

那么不同的用户请求来了，`DNS`会返回不同的`IP`所以这样就可以访问不同的服务器地址了。但是我们不能简单的使用`DNS`来进行负载均衡。为什么，因为`DNS`是有缓存的！这样就会导致用户始终访问一个服务器，就起不到负载均衡的效果了。

怎么能让用户的请求，公平的平均的分配到各个服务器？所以我们需要一个在服务器前面放一个特殊设备，当请求来了，到达这个特殊设备，由这个特殊设备来把请求分配给后面的服务器。最简单的调度算法就是轮训（`RR`）。

一个浏览器可以并发的起多个`http`请求，比如`chrome`应该是`6`个假设这`6`个请求分配到不同的服务器上了，那么就同时进行了请求，那么速度就非常的快。所以我们在浏览器中请求的对象可能来自多台不同的服务器。

调度算法有：

```
RR   轮训
WRR  加权轮训
```

![高可用-最初架构]()

数据库不能存放图片，那么这个图片放在硬盘上的一个目录里面，那么把这个文件的连接存放到数据库里面，这样就实现了附件图片的上传。









