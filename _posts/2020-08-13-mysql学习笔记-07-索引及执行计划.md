索引及执行计划    

## 1. 索引的作用      
类似于一本书中的目录,起到优化查询的作用       
## 2. 索引的分类(根据算法分类)      
B树    默认使用的索引类型        
R树    
Hash  mysql自适应的，不需要你管理的，mysql自己做的优化，你不用去关心它，自适应hash索引，存储引擎自动帮我们做的      
FullText   全文索引，类似于ES     
GIS 地理位置索引 （抄袭mongodb的功能，大部分的地图功能都是在mongodb中存储的）     

## 3. BTREE索引算法演变(了解)  
看图说话.     
mongodb也用的是B树     
linux的文件系统用的也是B树     

原始的B树

![原始的B树](https://github.com/Christian-health/christian-health.github.io/blob/master/img/%E5%8E%9F%E5%A7%8B%E7%9A%84B%E6%A0%91.jpg?raw=true)

查找33和88 
![B树](https://github.com/Christian-health/christian-health.github.io/blob/master/img/B-tree.JPG?raw=true)       
B树查找算法，查找一个东西更加公平一些，比如，二分法查找，也就是折半查找等，找到不同的元素，所要走的步数是不相等的，有的走几步就找到了但是有的需要走很多的步。     
所以不公平，慢慢的算法开始进化，变成了二叉平衡树等等，最后终于进化到B树，发现B树查找不同的元素，相对来说走的步数都很类似。所以就选择了B树作为最终的算法。    
最早期的B树，就是B-树，后来还有了B+树和B\*树     
现在mysql使用的是B\*树，也就是最高级的索引   
![B+树](https://github.com/Christian-health/christian-health.github.io/blob/master/img/B+tree.JPG?raw=true)          

普通的B树和B+的区别就在叶子节点上，**B+树上的叶子节点是有双向指针的。**   
如果要查找一个等于33，那么就从最顶上开始一层一层的找，就可以确定到底有没有33。但是如果要是找大于33那么就要先从顶上开始找33，然后开始找34，然后开始找35。   
这样频繁的访问磁盘效率会非常的差。代价就非常的高，所以我们要尽量去减少IO的消耗，所以针对这种范围查询就想了一种，查到33之后通过指针直接跳到下一个数据页，这样就减少了   
大量的IO，所以B+树，针对这种范围的查找又进行了一大步优化。   
![B星树](https://github.com/Christian-health/christian-health.github.io/blob/master/img/B%E6%98%9F%E6%A0%91.JPG?raw=true)      

而B\*树是在枝节点上也建立了双向指针，也得查询进一步优化。   
主要就是优化了大于等于，小于等于，like这样的语句。   
![B星树](https://github.com/Christian-health/christian-health.github.io/blob/master/img/%E7%B4%A2%E5%BC%95%E7%9A%84%E6%8C%87%E9%92%88.JPG?raw=true)   

索引也是存放在.ibd文件上的**图上的每一个节点都是一个数据页，也就是说都是16kb**,这个前面说过。   

## 4. Btree索引功能上的分类     

#### 4.1 辅助索引（二级索引）    
(0)管理员**选择一个列**创建辅助索引
(1) 提取索引列的所有值,进行排序         
(2) 将排好序的值,均匀的存放在叶子节点,进一步生成枝节点和根节点         
(3) 在叶子节点中的值,都会对应存储主键ID (比如一个学生表，我们使用name作为索引，通过索引树查找到了指定的name，然后我们要获取的不是只是这个name ，而是整个的学生信息，所以这个name还要存放一个指针，指向原表的位置，那么可以通过这个指针找到整个这个学生的信息)        
![索引的指针](https://raw.githubusercontent.com/Christian-health/christian-health.github.io/master/img/%E7%B4%A2%E5%BC%95%E7%9A%84%E6%8C%87%E9%92%88.JPG)  

前面说的是辅助索引，这里说的是聚集索引，为什么要引入聚集索引。前面我们的通过字典的目录找到了要查询的东西所在的页数，然后找到了要查询的东西。  
但是还是有一种可能，就是比如我通过目录找到了指定的页，但是发现，页是乱序的，比如第1页，第10页，第3页，等等。所以还要再乱序的页面附近翻一翻，为了解决这个问题，于是引入了聚集索引。  

辅助索引辅助的是谁，辅助的是聚集索引  

#### 4.2 聚集索引  
(1)MySQL 会自动选择**主键**作为聚集索引列,**没有主键会选择唯一键**,**如果都没有会生成隐藏的主键（5.5版本之后）**.   (2)MySQL进行存储数据时,会按照聚集索引列值的顺序,有序存储数据行     
(3)聚集索引直接将原表数据页,作为叶子节点,然后提取聚集索引列向上生成枝和根  

聚集索引一般是主键列，建表的时候一般就建立了主键，如果写书，页码是不规则的话找起来也不方便，写书之前就规划好了，页码是有顺序的，将来再去找页面的时候，有顺序就更加好找了。建立表的时候，强制用户输入数据，按照主键顺序，规划和存储我们的数据行，存的时候就有序了，按照主键顺序。就像写书一样，页码就是顺序。主键非空，唯一。聚集索引在录入数据自动生成了，自动的维护和增加，聚集索引由mysql自动维护的，只需要你设置一个主键就可以了。

聚集索引的特点是，直接将整行数据，按照顺序存储到叶子节点当中，上层的枝节点取列的最小值。


#### 4.3 聚集索引和辅助索引的区别   
(1) 表中任何一个列都可以创建辅助索引,在你有需要的时候,只要名字不同即可    
(2) 在一张表中,聚集索引只能有一个,一般是主键.  
(3) 辅助索引,叶子节点只存储索引列的有序值+聚集索引列值.  
(4) 聚集索引,叶子节点存储的时有序的整行数据.   
(5) MySQL 的表数据存储是聚集索引组织表   

最大的区别就是叶子节点不一样，辅助索引的叶子节点就是那一列的值，聚集索引的叶子节点是整行的值。


## 5. 辅助索引细分
5.1 单列辅助索引  
5.2 联合索引(覆盖索引)        
5.3 唯一索引              


## 6. 索引树高度
索引树高度应当越低越好,一般维持在3-4最佳
#### 6.1 数据行数较多
分表 : parttion  用的比较少了.
分片,分布式架构.
#### 6.2 字段长度
业务允许,尽量选择字符长度短的列作为索引列
业务不允许,采用前缀索引.
#### 6.3 数据类型
`char` 和 `varchar` 
`enum`


## 7. 索引的命令操作

#### 7.1  查询索引 
```
desc city;
PRI   ==> 主键索引 
MUL   ==> 辅助索引
UNI   ==> 唯一索引 

mysql> show index from city\G
```
#### 7.2 创建索引

单列的辅助索引:
```
mysql> alter table city add index idx_name(name);
```
多列的联合索引:
```
mysql> alter table city add index idx_c_p(countrycode,population);
```
唯一索引: 
```
mysql> alter table city add unique index uidx_dis(district);
```
```
mysql> select count(district) from city;
mysql> select count(distinct district) from city;
```
前缀索引
```
mysql> alter table city add index idx_dis(district(5));
```

#### 7.3 删除索引 
```
mysql> alter table city drop index idx_name;
mysql> alter table city drop index idx_c_p;
mysql> alter table city drop index idx_dis;
```

## 8. 压力测试准备:
```
mysql> use test
mysql> source /tmp/t100w.sql
```

#### 8.1 未做优化之前测试
```
mysqlslap --defaults-file=/etc/my.cnf \
--concurrency=100 --iterations=1 --create-schema='test' \
--query="select * from test.t100w where k2='MN89'" engine=innodb \
--number-of-queries=2000 -uroot -p123 -verbose

[root@db01 ~]# mysqlslap --defaults-file=/etc/my.cnf \
> --concurrency=100 --iterations=1 --create-schema='test' \
> --query="select * from test.t100w where k2='MN89'" engine=innodb \
> --number-of-queries=2000 -uroot -p123 -verbose
mysqlslap: [Warning] Using a password on the command line interface can be insecure.
Benchmark
	Running for engine rbose
	Average number of seconds to run all queries: 755.861 seconds
	Minimum number of seconds to run all queries: 755.861 seconds
	Maximum number of seconds to run all queries: 755.861 seconds
	Number of clients running queries: 100
	Average number of queries per client: 20
```
#### 8.2 索引优化后
```
[root@db01 ~]# mysqlslap --defaults-file=/etc/my.cnf --concurrency=100 --iterations=1 --create-schema='test' --query="select * from test.t100w where k2='MN89'" engine=innodb --number-of-queries=2000 -uroot -p123 -verbose
mysqlslap: [Warning] Using a password on the command line interface can be insecure.
Benchmark
	Running for engine rbose
	Average number of seconds to run all queries: 1.678 seconds
	Minimum number of seconds to run all queries: 1.678 seconds
	Maximum number of seconds to run all queries: 1.678 seconds
	Number of clients running queries: 100
	Average number of queries per client: 20
```


## 9. 执行计划分析
#### 9.1 作用
将优化器 选择后的执行计划 截取出来.便于管理管判断语句得执行效率.
#### 9.2 获取执行
desc   SQL语句
explain SQL 语句
```
mysql> desc select * from test.t100w where k2='MN89';
+----+-------------+-------+------------+------+---------------+------+---------+------+---------+----------+-------------+
| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows    | filtered | Extra       |
+----+-------------+-------+------------+------+---------------+------+---------+------+---------+----------+-------------+
|  1 | SIMPLE      | t100w | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 1027638 |    10.00 | Using where |
+----+-------------+-------+------------+------+---------------+------+---------+------+---------+----------+-------------+
```
#### 9.3 分析执行计划
###### 9.3.1 table        		
表名
###### 9.3.2 type				
查询的类型:
`全表扫描	 	: ALL `
`索引扫描    	: index,range,ref,eq_ref,const(system),NULL`

index: 全索引扫描
`mysql> desc select countrycode  from city;`

range: 索引范围扫描(> < >= <= , between and ,or,in,like )
`mysql> desc select * from city where id>2000;`
`mysql> desc select  * from city where countrycode like 'CH%';`

对于辅助索引来讲,!= 和not in等语句是不走索引的
对于主键索引列来讲,!= 和not in等语句是走range

===
`mysql> desc select  * from city where countrycode='CHN' or countrycode='USA';`
`mysql> desc select  * from city where countrycode in ('CHN','USA');`


一般改写为 union all 
```
desc 
select  * from city where countrycode='CHN' 
union all 
select  * from city where countrycode='USA';

ref: 辅助索引等值查询
desc 
select  * from city where countrycode='CHN' 
union all 
select  * from city where countrycode='USA';

eq_ref : 多表连接时,子表使用主键列或唯一列作为连接条件
A join B 
on a.x = B.y 

desc select b.name,a.name ,a.population  
from city as a 
join country as b 
on a.countrycode=b.code 
where a.population<100;

const(system) : 主键或者唯一键的等值查询
mysql> desc select * from  city where id=100;


possible_key
key
key_len
Extra
```


## 参考

https://blog.csdn.net/zhangf21/article/details/80212756?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.channel_param&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.channel_param
