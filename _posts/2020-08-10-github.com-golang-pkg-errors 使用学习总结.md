## Overview 总览
`Package errors provides simple error handling primitives.`    
errors包提供简单的错误处理原语    
`The traditional error handling idiom in Go is roughly akin to`  
Go中的传统错误处理习惯用法大致类似于    
```go
if err != nil {
        return err
}
```  
`which when applied recursively up the call stack results in error reports without context or debugging information. `  
当将其递归应用于调用堆栈时，将导致错误报告，而没有上下文或调试信息。    
`The errors package allows programmers to add context to the failure path in their code in a way that does not destroy the original value of the error.`

## Adding context to an error  向错误添加上下文  
`The errors.Wrap function returns a new error that adds context to the original error ,
by recording a stack trace , at the point errors.Wrap is called, together with the supplied message. For example`  
errors.Wrap函数返回一个新的错误，这个新的错误添加上下文content到原始的error中,记录errors.Wrap函数被调用地方的堆栈信息和给定的message。例如:    
```go
_, err := ioutil.ReadAll(r)
if err != nil {
        return errors.Wrap(err, "read failed")
}
```
`If additional control is required, the errors.WithStack and errors.WithMessage functions destructure errors.Wrap into its component operations: annotating an error with a stack trace and with a message, respectively.`  
如果需要其他控制，则errors.WithStack和errors.WithMessage函数会分解错误。包装到其组件操作：使用堆栈跟踪和消息分别注释错误。  

## Retrieving the cause of an error 检索错误原因
`Using errors.Wrap constructs a stack of errors, adding context to the preceding error. Depending on the nature of the error it may be necessary to reverse the operation of errors.Wrap to retrieve the original error for inspection. Any error value which implements this interface`  
使用[errors.Wrap]会构造一堆错误，为先前的错误添加上下文。 根据错误的性质，可能有必要反转[errors.Wrap]的操作以检索原始错误以进行检查。实现此接口的任何错误值  
```
type causer interface {
        Cause() error
}
```
`can be inspected by errors.Cause. errors.Cause will recursively retrieve the topmost error that does not implement causer, which is assumed to be the original cause. For example:`  
可以通过[errors.Cause]检查。 [errors.Cause]将递归检索未实现[causer]的最高错误，这被认为是原始原因。 例如：  
```
switch err := errors.Cause(err).(type) {
case *MyError:
        // handle specifically
default:
        // unknown error
}
```
`Although the causer interface is not exported by this package, it is considered a part of its stable public interface.`  
尽管此包未导出[causer]接口，但它被认为是其稳定公共接口的一部分。  

### Formatted printing of errors 格式化打印错误  
`All error values returned from this package implement fmt.Formatter and can be formatted by the fmt package. The following verbs are supported:`  
从此程序包返回的所有错误值都实现fmt.Formatter，并且可以由fmt程序包格式化。 支持以下动词：  
```
%s    print the error. If the error has a Cause it will be
      printed recursively.
%v    see %s
%+v   extended format. Each Frame of the error's StackTrace will
      be printed in detail.
```
## Retrieving the stack trace of an error or wrapper 检索[error或wrapper]的堆栈跟踪
`New, Errorf, Wrap, and Wrapf record a stack trace at the point they are invoked. This information can be retrieved with the following interface:`  
New，Errorf，Wrap和Wrapf在调用它们时记录堆栈跟踪。 可以通过以下接口检索此信息：   
```
type stackTracer interface {
        StackTrace() errors.StackTrace
}
```
`The returned errors.StackTrace type is defined as`
返回的errors.StackTrace类型定义为  

```
type StackTrace []Frame
```
`The Frame type represents a call site in the stack trace. Frame supports the fmt.Formatter interface that can be used for printing information about the stack trace of this error. For example:`  
[Frame]类型表示堆栈跟踪中的调用站点。 Frame支持fmt.Formatter接口，该接口可用于打印有关此错误的堆栈跟踪的信息。 例如：  
```
if err, ok := err.(stackTracer); ok {
        for _, f := range err.StackTrace() {
                fmt.Printf("%+s:%d\n", f, f)
        }
}
```
`Although the stackTracer interface is not exported by this package, it is considered a part of its stable public interface.`   
尽管stackTracer接口未由此程序包导出，但它被视为其稳定的公共接口的一部分。  
`See the documentation for Frame.Format for more details.`  
有关更多详细信息，请参见Frame.Format文档。  

## Example (StackTrace) 
```
Code:

type stackTracer interface {
	StackTrace() errors.StackTrace
}

err, ok := errors.Cause(fn()).(stackTracer)
if !ok {
	panic("oops, err does not implement stackTracer")
}

st := err.StackTrace()
fmt.Printf("%+v", st[0:2])
```
## func As
```
func As(err error, target interface{}) bool
```
`As finds the first error in err's chain that matches target, and if so, sets target to that error value and returns true.`  
As在err链中找到与目标匹配的第一个错误，如果匹配，则将target设置为该错误值并返回true。  

`The chain consists of err itself followed by the sequence of errors obtained by repeatedly calling Unwrap.`  
该链由err本身组成，其后是通过重复调用Unwrap获得的错误序列。  

`An error matches target if the error's concrete value is assignable to the value pointed to by target, or if the error has a method As(interface{}) bool such that As(target) returns true. In the latter case, the As method is responsible for setting target.  `

`As will panic if target is not a non-nil pointer to either a type that implements error, or to any interface type. As returns false if err is nil.  `

### func Cause 
```
func Cause(err error) error
```
Cause returns the underlying cause of the error, if possible. An error value has a cause if it implements the following interface:  
如果可能，Cause返回错误的根本原因。如果error实现以下接口，则它是有cause的：  
```
type causer interface {
       Cause() error
}
```
`If the error does not implement Cause, the original error will be returned. If the error is nil, nil will be returned without further investigation.`  
如果一个error没有实现Cause方法，原始的error将会被返回。如果一个error是nil，那么nil将会被返回无需进一步调查。  
```
Code:

err := fn()
fmt.Println(err)
fmt.Println(errors.Cause(err))
outer: middle: inner: error
error

```

## Example (Printf) 
```
Code:

err := errors.Wrap(func() error {
	return func() error {
		return errors.New("hello world")
	}()
}(), "failed")

fmt.Printf("%v", err)
failed: hello world
```
## func Errorf 
```
func Errorf(format string, args ...interface{}) error
```
`Errorf formats according to a format specifier and returns the string as a value that satisfies error. Errorf also records the stack trace at the point it was called.`  
Errorf根据格式说明符设置格式，并将字符串作为满足错误的值返回。Errorf还会在调用时记录堆栈跟踪。   
```
Example (Extended) 
Code:

err := errors.Errorf("whoops: %s", "foo")
fmt.Printf("%+v", err)
```

## func Is
`func Is(err, target error) bool`

`Is reports whether any error in err's chain matches target.`  
Is报告err链中的任何错误是否与目标匹配。  
`The chain consists of err itself followed by the sequence of errors obtained by repeatedly calling Unwrap.`  
这个链由err本身和通过反复调用Unwrap获得的错误序列组成。  
`An error is considered to match a target if it is equal to that target or if it implements a method Is(error) bool such that Is(target) returns true.`
error被视为与target匹配。如果它等于该目标，或者如果它实现了一个方法is（error），并且is（target）将返回true。  

## func New 
```
func New(message string) error
```
`New returns an error with the supplied message. New also records the stack trace at the point it was called.`  
New使用提供的消息返回错误。 New还会在调用时记录堆栈跟踪。  

```
Example
Code:
err := errors.New("whoops")
fmt.Println(err)
whoops
```
```
Example (Printf) 
Code:

err := errors.New("whoops")
fmt.Printf("%+v", err)
```
## func Unwrap
```
func Unwrap(err error) error
```
`Unwrap returns the result of calling the Unwrap method on err, if err's type contains an Unwrap method returning error. Otherwise, Unwrap returns nil.`  
如果err的类型包含返回错误的[Unwrap]方法，则[Unwrap]返回对err调用[Unwrap]方法的结果。 否则，[Unwrap]返回nil。  

## func WithMessage 
```func WithMessage(err error, message string) error```
`WithMessage annotates err with a new message. If err is nil, WithMessage returns nil.`  
WithMessage用新消息注解err。 如果err为nil，则WithMessage返回nil。  

```
Example 
Code:

cause := errors.New("whoops")
err := errors.WithMessage(cause, "oh noes")
fmt.Println(err)
oh noes: whoops
```

## func WithMessagef 
```
func WithMessagef(err error, format string, args ...interface{}) error
```
`WithMessagef annotates err with the format specifier. If err is nil, WithMessagef returns nil.`
WithMessagef用格式说明符注解err。 如果err为nil，则WithMessagef返回nil。

## func WithStack 
```
func WithStack(err error) error
```
`WithStack annotates err with a stack trace at the point WithStack was called. If err is nil, WithStack returns nil.`
在调用WithStack时，WithStack用堆栈跟踪注解err。 如果err为nil，则WithStack返回nil。

```
Example
Code:

cause := errors.New("whoops")
err := errors.WithStack(cause)
fmt.Println(err)
whoops
```
```
Example (Printf) 
Code:

cause := errors.New("whoops")
err := errors.WithStack(cause)
fmt.Printf("%+v", err)
```
## func Wrap
```
func Wrap(err error, message string) error
```
`Wrap returns an error annotating err with a stack trace at the point Wrap is called, and the supplied message. If err is nil, Wrap returns nil.`  
Wrap返回一个错误，该错误在调用Wrap的点处带有堆栈跟踪的err注解，并提供了消息。 如果err为nil，则Wrap返回nil。  
```
Example 
Code:

cause := errors.New("whoops")
err := errors.Wrap(cause, "oh noes")
fmt.Println(err)
oh noes: whoops
```
```
Example (Extended) 
Code:

err := fn()
fmt.Printf("%+v\n", err)
```

## func Wrapf
```
func Wrapf(err error, format string, args ...interface{}) error
```
`Wrapf returns an error annotating err with a stack trace at the point Wrapf is called, and the format specifier. If err is nil, Wrapf returns nil.`  
Wrapf返回错误，并在调用Wrapf的点处用堆栈跟踪注释err，并指定格式说明符。 如果err为nil，则Wrapf返回nil。  

```
Example 
Code:

cause := errors.New("whoops")
err := errors.Wrapf(cause, "oh noes #%d", 2)
fmt.Println(err)
oh noes #2: whoops
```
## type Frame 
```
type Frame uintptr
```
`Frame represents a program counter inside a stack frame. For historical reasons if Frame is interpreted as a uintptr its value represents the program counter + 1.`  
[Frame]表示堆栈框架内的程序计数器。 由于历史原因，如果将Frame解释为uintptr，则其值表示程序计数器+ 1。  

## func (Frame) Format 
```
func (f Frame) Format(s fmt.State, verb rune)
```
`Format formats the frame according to the fmt.Formatter interface.`  
Format根据fmt.Formatter接口格式化框架。  
```
%s    source file
%d    source line
%n    function name
%v    equivalent to %s:%d
```
`Format accepts flags that alter the printing of some verbs, as follows:`  
Format接受更改某些打印标志的动词，如下所示：  
```
%+s   function name and path of source file relative to the compile time
      GOPATH separated by \n\t (<funcname>\n\t<path>)
%+v   equivalent to %+s:%d
```
## func (Frame) MarshalText 
```
func (f Frame) MarshalText() ([]byte, error)
```
`MarshalText formats a stacktrace Frame as a text string. The output is the same as that of fmt.Sprintf("%+v", f), but without newlines or tabs.`  
MarshalText将stacktrace Frame格式化为文本字符串。 输出与fmt.Sprintf（“％+ v”，f）相同，但没有换行符或制表符。  

## type StackTrace 
```type StackTrace []Frame```   
`StackTrace is stack of Frames from innermost (newest) to outermost (oldest).`  
StackTrace是从最里面（最新）到最外面（最旧）的帧堆栈。  

## func (StackTrace) Format 
```
func (st StackTrace) Format(s fmt.State, verb rune)
```
`Format formats the stack of Frames according to the fmt.Formatter interface.`  
Format根据fmt.Formatter接口格式化frame堆栈。  
```
%s	lists source files for each Frame in the stack
%v	lists the source file and line number for each Frame in the stack
```
`Format accepts flags that alter the printing of some verbs, as follows:`  
Format接受某些动词更改打印的标志，如下所示：  
```
%+v   Prints filename, function, and line number for each Frame in the stack.
```




## 
## 参考
- [Go语言(golang)的错误(error)处理的推荐方案](https://studygolang.com/articles/17430?fr=sidebar)
 
