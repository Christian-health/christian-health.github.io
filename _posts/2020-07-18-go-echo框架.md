---
layout:     post
title:      "echo框架使用学习总结"
subtitle:   "echo"
data:       ""
author:     ""
header-img: img/echo-back-title.jpg
catalog: true
tags:
    - echo
    - go
---



## 为什么选择echo框架？



## 安装运行

​		（1）使用goland创建一个echodemo的项目的目录

​		（2）执行go mod init echodemo，将会生成go.mod文件

​		（3）创建src目录和main目录，并创建main.go

​		（4）拷贝echo官网的demo到main.go

​		（5）执行go run main.go，在执行过程中会自动下载所依赖的echo包，同时将会更新go.mod和go.sum两个文件 

![echo运行成功](https://github.com/Christian-health/christian-health.github.io/blob/master/img/echo-simple-run.jpg?raw=true)



## 使用echo

#### 1、自定义

echo框架可以自定义如下的内容，有些内容有很长，需要单独的章节来总结。

- 自定义
    - Debug
    - 日志
        - 日志输出 
        - 日志级别
        - 自定义日志
    - 自定义 Server
        - 使用 Echo#StartServer()
        - 启动横幅
        - 自定义监听器
- 禁用 HTTP/2
- 读取超时
- 写入超时
- 验证
- 自定义绑定
- 渲染
- HTTP 错误处理

```go
package main

import (
   "github.com/labstack/gommon/log"
   "io"
   "net/http"
   "os"

   "github.com/labstack/echo/v4"
)

func main() {
   // 创建一个Echo的instance
   e := echo.New()
   /*
     用来关闭启动时候的横幅，也就是在启动的控制台上不要打印出如下内容
     D:\gowork\echo\src\main>go run  main.go

      ____    __
     / __/___/ /  ___
    / _// __/ _ \/ _ \
   /___/\__/_//_/\___/ v4.1.16
   High performance, minimalist Go web framework
   https://echo.labstack.com
   ____________________________________O/_______
                                       O\
   ⇨ http server started on [::]:1323
   */
   e.HideBanner=false

   // 用于关闭HTTP/2协议
   e.DisableHTTP2=true

   //用于设置读取请求的最大时间。

   //用于设置日志输出的位置，默认是 os.Stdout
   e.Logger.SetOutput(io.Writer(os.Stdout))

   //下面两个设置完全禁用日志。
   //e.Logger.SetOutput(ioutil.Discard)
   //e.Logger.SetLevel(log.OFF)

   //设置日志级别
   e.Logger.SetLevel(log.DEBUG)
   //e.Logger.SetLevel(log.INFO)
   //e.Logger.SetLevel(log.WARN)
   //e.Logger.SetLevel(log.ERROR)
   //e.Logger.SetLevel(log.OFF)

   // Routes
   e.GET("/", hello)

   // Start server
   e.Logger.Fatal(e.Start(":1323"))
}

type customerLogger struct {
   Logger echo.Logger
}

// Handler
func hello(c echo.Context) error {
   return c.String(http.StatusOK, "Hello World,customize!")
}	
```

## Context

echo.Context 代表了当前 HTTP 请求的 context（上下文），它含有请求和相应的引用，路径，路径参数，数据，注册的业务处理方法和读取请求和输出响应的API。由于 Context 是一个接口，所以也可以很方便的使用自定义的 API 扩展。
```go
package main

import (
	"net/http"

	"github.com/labstack/echo/v4"
	"github.com/labstack/echo/v4/middleware"
)

/*
	扩展 Context
	定义一个自定义 context
*/
type CustomContext struct {
	echo.Context
}

func (c *CustomContext) Foo() {
	println("foo function run")
}

func (c *CustomContext) Bar() {
	println("bar function run")
}

func main() {
	// Echo instance
	e := echo.New()

	// Middleware
	/*
		创建一个中间件来扩展默认的 context
		此中间件应在任何其他中间件之前注册
	*/
	e.Use(func(next echo.HandlerFunc) echo.HandlerFunc {
		return func(c echo.Context) error {
			println("middleware customcontext run")
			cc := &CustomContext{c}
			return next(cc)
		}
	})

	e.Use(middleware.Logger())
	e.Use(middleware.Recover())

	// Routes
	e.GET("/", hello)

	//在处理器中使用自定义的context
	e.GET("/content", func(c echo.Context) error {
		cc := c.(*CustomContext)
		//cc.Foo()
		//cc.Bar()
		return cc.String(200, "OK")
	})

	// Start server
	e.Logger.Fatal(e.Start(":1323"))
}

// Handler
func hello(c echo.Context) error {
	return c.String(http.StatusOK, "Hello, World!")
}

```
## Cookies
Cookie 是用户访问网站时浏览器上存储的小型文本文件，由服务器发送而来。每当用户加载网站时，浏览器都会将 cookie 发送回服务器以通知用户之前的活动。 Cookie 作为一个可靠验证凭据，可用来记录状态信息（比如在线商城购物车中的商品）或记录用户的浏览器活动（包括单击特定按钮，登录或记录访问过的页面）。Cookie 还可以存储用户先前输入的密码和表单内容，例如信用卡号或地址。

Cookie 属性
|属性 | 可选 |
| -- | -- |
| Name | No |
| Value	| No |
| Path	| Yes |
| Domain | Yes |
| Expires | Yes|
| Secure | Yes |
| HTTPOnly | Yes |

Echo 使用 golang 自带的 http.Cookie 对象写入／读取从上下文中的 cookie。

```go
package main

import (
	"fmt"
	"net/http"
	"time"

	"github.com/labstack/echo/v4"
	"github.com/labstack/echo/v4/middleware"
)

func main() {
	// Echo instance
	e := echo.New()

	// Middleware
	e.Use(middleware.Logger())
	e.Use(middleware.Recover())

	// Routes
	e.GET("/", hello)

	// 写入cookie
	e.GET("/writeCookie", writeCookie)
	// 读取cookie
	e.GET("/readCookie", readCookie)
	// 读取所有的cookie
	e.GET("/readAllCookies", readAllCookies)

	// Start server
	e.Logger.Fatal(e.Start(":1323"))
}

// Handler
func hello(c echo.Context) error {
	return c.String(http.StatusOK, "Hello, World!")
}

/*
写cookie
使用 new(http.Cookie) 创建Cookie。
cookie 的属性值会被赋值给 http.Cookie 的可导出属性。
最后，使用 c.SetCookie(cookies) 来给 HTTP 响应增加 Set-Cookie 头。
*/
func writeCookie(c echo.Context) error {
	cookie := new(http.Cookie)
	cookie.Name = "username"
	cookie.Value = "jon"
	cookie.Expires = time.Now().Add(24 * time.Hour)
	c.SetCookie(cookie)
	return c.String(http.StatusOK, "write a cookie")
}

/*
读cookie
Cookie 通过名称从 HTTP 请求里读取：c.Cookie("name")。
Cookie 的属性可以使用 Getter 方法获取。
*/
func readCookie(c echo.Context) error {
	cookie, err := c.Cookie("username")
	if err != nil {
		return err
	}
	fmt.Println("read cookie Name :", cookie.Name)
	fmt.Println("read cookie Value :", cookie.Value)
	return c.String(http.StatusOK, "read a cookie")
}

// 读取所有的cookie
func readAllCookies(c echo.Context) error {
	for index, cookie := range c.Cookies() {
		fmt.Printf("read all cookie,index is %v Name %s\n", index, cookie.Name)
		fmt.Printf("read all cookie,index is %v Value %s\n", index, cookie.Value)
	}
	return c.String(http.StatusOK, "read all the cookies")
}
/*
[root]$ go run main.go 

   ____    __
  / __/___/ /  ___
 / _// __/ _ \/ _ \
/___/\__/_//_/\___/ v4.1.16
High performance, minimalist Go web framework
https://echo.labstack.com
____________________________________O/_______
                                    O\
⇨ http server started on [::]:1323
read all cookie,index is 0 Name username //读所有的cookie
read all cookie,index is 0 Value jon 
{"time":"2020-07-18T21:23:28.246793142+08:00","id":"","remote_ip":"::1","host":"localhost:1323","method":"GET","uri":"/readAllCookies","user_agent":"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/79.0.3945.79 Safari/537.36","status":200,"error":"","latency":163405,"latency_human":"163.405µs","bytes_in":0,"bytes_out":20}
read cookie Name : username //读取单个cookie
read cookie Value : jon
{"time":"2020-07-18T21:24:53.078681646+08:00","id":"","remote_ip":"::1","host":"localhost:1323","method":"GET","uri":"/readCookie","user_agent":"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/79.0.3945.79 Safari/537.36","status":200,"error":"","latency":40588,"latency_human":"40.588µs","bytes_in":0,"bytes_out":13}
*/
```
# 请求

- 请求

  - 数据绑定

    - [JSON 数据](https://www.bookstack.cn/read/echo-v3-zh/guide-request.md#JSON%20%E6%95%B0%E6%8D%AE)
    - [Form 表单数据](https://www.bookstack.cn/read/echo-v3-zh/guide-request.md#Form%20%E8%A1%A8%E5%8D%95%E6%95%B0%E6%8D%AE)
    - [查询参数 (Query Parameters)](https://www.bookstack.cn/read/echo-v3-zh/guide-request.md#%E6%9F%A5%E8%AF%A2%E5%8F%82%E6%95%B0%20(Query%20Parameters))

  - [自定义绑定器](https://www.bookstack.cn/read/echo-v3-zh/guide-request.md#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%91%E5%AE%9A%E5%99%A8)

  - 检索数据

    - [Form 表单数据](https://www.bookstack.cn/read/echo-v3-zh/guide-request.md#Form%20%E8%A1%A8%E5%8D%95%E6%95%B0%E6%8D%AE)
    - [查询参数 (Query Parameters)](https://www.bookstack.cn/read/echo-v3-zh/guide-request.md#%E6%9F%A5%E8%AF%A2%E5%8F%82%E6%95%B0%20(Query%20Parameters))
    - [路径参数 (Path Parameters)](https://www.bookstack.cn/read/echo-v3-zh/guide-request.md#%E8%B7%AF%E5%BE%84%E5%8F%82%E6%95%B0%20(Path%20Parameters))

  - 数据验证
  
### 数据绑定
```go
package main

import (
	"fmt"
	"net/http"

	"github.com/labstack/echo/v4"
	"github.com/labstack/echo/v4/middleware"
)

// User
type User struct {
	Name  string `json:"name" form:"name" query:"name"`
	Email string `json:"email" form:"email" query:"email"`
}

func main() {
	// Echo instance
	e := echo.New()

	// Middleware
	e.Use(middleware.Logger())
	e.Use(middleware.Recover())

	// Routes
	e.GET("/", hello)

	// 测试post绑定
	e.GET("/users", getUsers)

	// 测试post绑定
	e.POST("/users", postUsers)

	// Start server
	e.Logger.Fatal(e.Start(":1323"))
}

// Handler
func hello(c echo.Context) error {
	return c.String(http.StatusOK, "Hello, World!")
}

func getUsers(c echo.Context) (err error) {
	fmt.Println("get to users, getUsers function fun")
	u := new(User)
	if err = c.Bind(u); err != nil {
		return
	}
	return c.JSON(http.StatusOK, u)
}

// Handler
func postUsers(c echo.Context) (err error) {
	fmt.Println("post to users, postUsers function fun")
	u := new(User)
	if err = c.Bind(u); err != nil {
		return
	}
	return c.JSON(http.StatusOK, u)
}
/*
新开一个终端运行如下curl命令：
[root@LIN-6A14041F8B1 src]# curl   -X GET   http://localhost:1323/users\?name\=Joe\&email\=joe@labstack.com
{"name":"Joe","email":"joe@labstack.com"}
[root@LIN-6A14041F8B1 src]# curl -X POST "http://localhost:1323/users" -H "Content-Type: application/json" -d '{"name":"Joe","email":"joe@labstack"}'
{"name":"Joe","email":"joe@labstack"}
[root@LIN-6A14041F8B1 src]# curl -X POST http://localhost:1323/users -d 'name=Joe' -d 'email=joe@labstack.com'
{"name":"Joe","email":"joe@labstack.com"}
[root@LIN-6A14041F8B1 src]# 

Server的终端显示如下结果:
[10200896@zte.intra@LIN-6A14041F8B1 main]$ go run main.go 

   ____    __
  / __/___/ /  ___
 / _// __/ _ \/ _ \
/___/\__/_//_/\___/ v4.1.16
High performance, minimalist Go web framework
https://echo.labstack.com
____________________________________O/_______
                                    O\
⇨ http server started on [::]:1323
get to users, getUsers function fun
{"time":"2020-07-19T09:25:27.822184902+08:00","id":"","remote_ip":"127.0.0.1","host":"localhost:1323","method":"GET","uri":"/users?name=Joe&email=joe@labstack.com","user_agent":"curl/7.51.0","status":200,"error":"","latency":189588,"latency_human":"189.588µs","bytes_in":0,"bytes_out":42}
post to users, postUsers function fun
{"time":"2020-07-19T09:25:34.163877389+08:00","id":"","remote_ip":"127.0.0.1","host":"localhost:1323","method":"POST","uri":"/users","user_agent":"curl/7.51.0","status":200,"error":"","latency":104889,"latency_human":"104.889µs","bytes_in":37,"bytes_out":38}
post to users, postUsers function fun
{"time":"2020-07-19T09:25:37.913292269+08:00","id":"","remote_ip":"127.0.0.1","host":"localhost:1323","method":"POST","uri":"/users","user_agent":"curl/7.51.0","status":200,"error":"","latency":126059,"latency_human":"126.059µs","bytes_in":31,"bytes_out":42}

*/
```
### 自定义绑定器
```go
//服务端代码
package main

import (
	"fmt"
	"net/http"
	"strings"

	"github.com/labstack/echo/v4"
	"github.com/labstack/echo/v4/middleware"
	"github.com/vmihailenco/msgpack"
)

type User struct {
	Name string `json:"name"`
	Sex  string `json:"sex"`
}

type MsgpackBinder struct{}

func (b *MsgpackBinder) Bind(i interface{}, ctx echo.Context) (err error) {
	fmt.Println("MsgpackBinder Bind run before echo DefaultBinder")
	// 也支持默认 Binder 相关的绑定
	db := new(echo.DefaultBinder)
	if err = db.Bind(i, ctx); err != echo.ErrUnsupportedMediaType {
		return
	}
	fmt.Println("MsgpackBinder Bind run after echo DefaultBinder")
	req := ctx.Request()
	ctype := req.Header.Get(echo.HeaderContentType)
	if strings.HasPrefix(ctype, echo.MIMEApplicationMsgpack) {
		if err = msgpack.NewDecoder(req.Body).Decode(i); err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, err.Error()).SetInternal(err)
		}
		fmt.Println("MsgpackBinder Bind run before MsgpackBinder return")
		return
	}

	return echo.ErrUnsupportedMediaType
}

func main() {
	// Echo instance
	e := echo.New()
	e.Binder = new(MsgpackBinder)

	// Middleware
	e.Use(middleware.Logger())
	e.Use(middleware.Recover())

	// Routes
	e.GET("/", helloGet)
	e.POST("/", helloPost)

	// Start server
	e.Logger.Fatal(e.Start(":1323"))
}

// Handler
func helloPost(c echo.Context) (err error) {
	fmt.Println("post to users, postUsers function fun")
	u := new(User)
	if err = c.Bind(u); err != nil {
		return
	}
	return c.JSON(http.StatusOK, u)
}

func helloGet(c echo.Context) error {
	fmt.Println("get to users, getUsers function fun")
	return c.String(http.StatusOK, "Hello, world hello Get!")
}
/*运行结果
[root]$ go run main.go 

   ____    __
  / __/___/ /  ___
 / _// __/ _ \/ _ \
/___/\__/_//_/\___/ v4.1.16
High performance, minimalist Go web framework
https://echo.labstack.com
____________________________________O/_______
                                    O\
⇨ http server started on [::]:1323
post to users, postUsers function fun
MsgpackBinder Bind run before echo DefaultBinder
MsgpackBinder Bind run after echo DefaultBinder
MsgpackBinder Bind run before MsgpackBinder return
{"time":"2020-07-19T13:57:52.302913939+08:00","id":"","remote_ip":"127.0.0.1","host":"localhost:1323","method":"POST","uri":"/","user_agent":"Go-http-client/1.1","status":200,"error":"","latency":229598,"latency_human":"229.598µs","bytes_in":24,"bytes_out":33}

*/

```
```go
客户端代码
package main

import (
    "bytes"
    "fmt"
    "io/ioutil"
    "net/http"

    "github.com/vmihailenco/msgpack"
)

func main() {
    type User struct {
        Name string
        Sex  string
    }

    b, err := msgpack.Marshal(&User{Name: "tom", Sex: "male"})
    if err != nil {
        panic(err)
    }

    resp, err := http.DefaultClient.Post("http://localhost:1323/", "application/msgpack", bytes.NewReader(b))
    if err != nil {
        panic(err)
    }
    defer resp.Body.Close()

    result, err := ioutil.ReadAll(resp.Body)
    if err != nil {
        panic(err)
    }

    fmt.Printf("%s\n", result)
}
/*
运行结果
[root]$ go run main.go 
{"name":"tom","sex":"male"}
*/
```
### 数据验证

### 路径参数 (Path Parameters)

### 查询参数 (Query Parameters)

### Form 表单数据

```go
package main

import (
	"net/http"

	"github.com/go-playground/validator/v10"
	"github.com/labstack/echo/v4"
	"github.com/labstack/echo/v4/middleware"
)

type (
	User struct {
		Name  string `json:"name" validate:"required"`
		Email string `json:"email" validate:"required,email"`
	}
	CustomValidator struct {
		validator *validator.Validate
	}
)

func (cv *CustomValidator) Validate(i interface{}) error {
	return cv.validator.Struct(i)
}

func main() {
	// Echo instance
	e := echo.New()
	e.Validator = &CustomValidator{validator: validator.New()}

	// Middleware
	e.Use(middleware.Logger())
	e.Use(middleware.Recover())

	// Routes
	e.GET("/", hello)

	e.POST("/postName", FormNameValue)

	e.GET("/getName", queryName)

	// 路径参数 (Path Parameters)
	e.GET("/users/:name", func(c echo.Context) error {
		name := c.Param("name")
		return c.String(http.StatusOK, "Path Parameters : "+name)
	})

	e.POST("/users", func(c echo.Context) (err error) {
		u := new(User)
		if err = c.Bind(u); err != nil {
			return
		}
		if err = c.Validate(u); err != nil {
			return
		}
		return c.JSON(http.StatusOK, u)
	})

	// Start server
	e.Logger.Fatal(e.Start(":1323"))
}

// Handler
func hello(c echo.Context) error {
	return c.String(http.StatusOK, "Hello, World!")
}

/*
Form 表单数据
curl -X POST http://localhost:1323/postName -d 'name=Joe'
运行上面curl命令返回结果:Joe
*/
func FormNameValue(c echo.Context) error {
	name := c.FormValue("name")
	return c.String(http.StatusOK, "FormNameValue : "+name)
}

// 查询参数 (Query Parameters)
func queryName(c echo.Context) error {
	name := c.QueryParam("name")
	return c.String(http.StatusOK, "queryName : "+name)
}
/*
[root]# curl -X POST http://localhost:1323/postName -d 'name=Joe'
FormNameValue : Joe
[root]# curl -X GET http://localhost:1323/getName\?name\=Joe
queryName : Joe
[root]# curl http://localhost:1323/users/Joe
Joe
[root]# curl http://localhost:1323/users/Joe
Path Parameters : Joe
[root]# curl -X GET http://localhost:1323/getName\?name\=Joe
queryName : Joe
[root]# curl -X POST http://localhost:1323/postName -d 'name=Joe'
FormNameValue : Joe
[root]# curl -X POST http://localhost:1323/users -H 'Content-Type: application/json' -d '{"name":"Joe","email":"joe@invalid-domain"}'
{"message":"Internal Server Error"}
*/

```

##  响应

 响应

- [发送 string 数据](https://www.bookstack.cn/read/echo-v3-zh/guide-response.md#%E5%8F%91%E9%80%81%20string%20%E6%95%B0%E6%8D%AE)
- 发送 HTML 响应 (参考模板)
  - [发送 HTML Blob](https://www.bookstack.cn/read/echo-v3-zh/guide-response.md#%E5%8F%91%E9%80%81%20HTML%20Blob)
- [模版引擎渲染](https://www.bookstack.cn/read/echo-v3-zh/guide-response.md#%E6%A8%A1%E7%89%88%E5%BC%95%E6%93%8E%E6%B8%B2%E6%9F%93)
- 发送 JSON 数据
  - [JSON 流](https://www.bookstack.cn/read/echo-v3-zh/guide-response.md#JSON%20%E6%B5%81)
  - [JSON 美化 (JSON Pretty)](https://www.bookstack.cn/read/echo-v3-zh/guide-response.md#JSON%20%E7%BE%8E%E5%8C%96%20(JSON%20Pretty))
  - [JSON Blob](https://www.bookstack.cn/read/echo-v3-zh/guide-response.md#JSON%20Blob)
- [发送 JSONP 数据](https://www.bookstack.cn/read/echo-v3-zh/guide-response.md#%E5%8F%91%E9%80%81%20JSONP%20%E6%95%B0%E6%8D%AE)
- 发送 XML 数据
  - [XML 流](https://www.bookstack.cn/read/echo-v3-zh/guide-response.md#XML%20%E6%B5%81)
  - [XML 美化 (XML Pretty)](https://www.bookstack.cn/read/echo-v3-zh/guide-response.md#XML%20%E7%BE%8E%E5%8C%96%20(XML%20Pretty))
  - [XML Blob](https://www.bookstack.cn/read/echo-v3-zh/guide-response.md#XML%20Blob)
- [发送文件](https://www.bookstack.cn/read/echo-v3-zh/guide-response.md#%E5%8F%91%E9%80%81%E6%96%87%E4%BB%B6)
- [发送附件](https://www.bookstack.cn/read/echo-v3-zh/guide-response.md#%E5%8F%91%E9%80%81%E9%99%84%E4%BB%B6)
- [发送内嵌 (Inline)](https://www.bookstack.cn/read/echo-v3-zh/guide-response.md#%E5%8F%91%E9%80%81%E5%86%85%E5%B5%8C%20(Inline))
- [发送二进制长文件 (Blob)](https://www.bookstack.cn/read/echo-v3-zh/guide-response.md#%E5%8F%91%E9%80%81%E4%BA%8C%E8%BF%9B%E5%88%B6%E9%95%BF%E6%96%87%E4%BB%B6%20(Blob))
- [发送流 (Stream)](https://www.bookstack.cn/read/echo-v3-zh/guide-response.md#%E5%8F%91%E9%80%81%E6%B5%81%20(Stream))
- [发送空内容 (No Content)](https://www.bookstack.cn/read/echo-v3-zh/guide-response.md#%E5%8F%91%E9%80%81%E7%A9%BA%E5%86%85%E5%AE%B9%20(No%20Content))
- [重定向](https://www.bookstack.cn/read/echo-v3-zh/guide-response.md#%E9%87%8D%E5%AE%9A%E5%90%91)
- Hooks
  - [响应之前](https://www.bookstack.cn/read/echo-v3-zh/guide-response.md#%E5%93%8D%E5%BA%94%E4%B9%8B%E5%89%8D)
  - [响应之后](https://www.bookstack.cn/read/echo-v3-zh/guide-response.md#%E5%93%8D%E5%BA%94%E4%B9%8B%E5%90%8E)

```go

package main

import (
	"encoding/json"
	"net/http"
	"os"

	"github.com/labstack/echo"
	"github.com/labstack/echo/middleware"
)

// User
type User struct {
	Name  string `json:"name" xml:"name"`
	Email string `json:"email" xml:"email"`
}

const (
	FilePath = "./main.go"
	Name     = "mainCopy.go"
	Image    = "image.png"
	Baidu    = "../sendFile" //最开始写的是https://www.baidu.com但是重定向之后拼接的url是有问题的
)

func main() {
	// Echo instance
	e := echo.New()
	// Middleware
	e.Use(middleware.Logger())
	e.Use(middleware.Recover())
	// Route => handler
	e.GET("/", func(c echo.Context) error {
		return c.String(http.StatusOK, "Hello, World!\n")
	})

	//curl -X GET "http://127.0.0.1:1323/contentString" -H "Content-Type: application/json"
	e.GET("/contentString", func(c echo.Context) error {
		return c.String(http.StatusOK, "echo content string\n")
	})

	//curl -X GET "http://127.0.0.1:1323/contentHTML" -H "Content-Type: application/json"
	e.GET("/contentHTML", func(c echo.Context) error {
		return c.HTML(http.StatusOK, "<strong>Hello, World!</strong>")
	})

	//curl -X GET "http://127.0.0.1:1323/contentJSON" -H "Content-Type: application/json"
	e.GET("/contentJSON", contentJSON)

	//curl -X GET "http://127.0.0.1:1323/contentJSONUsePointer" -H "Content-Type: application/json"
	e.GET("/contentJSONUsePointer", contentJSONUsePointer)
	//curl -X GET "http://127.0.0.1:1323/contentJSONUseNewEncoder" -H "Content-Type: application/json"
	e.GET("/contentJSONUseNewEncoder", contentJSONUseNewEncoder)
	//curl -X GET "http://127.0.0.1:1323/contentJSONPretty" -H "Content-Type: application/json"
	e.GET("/contentJSONPretty", contentJSONPretty)
	//curl -X GET "http://127.0.0.1:1323/sendFile" -H "Content-Type: application/json"
	e.GET("/sendFile", sendFile)
	//curl -X GET "http://127.0.0.1:1323/sendAttachment" -H "Content-Type: application/json"
	e.GET("/sendAttachment", sendAttachment)
	//curl -X GET "http://127.0.0.1:1323/sendInline" -H "Content-Type: application/json"
	e.GET("/sendInline", sendInline)
	//curl -X GET "http://127.0.0.1:1323/sendBlob" -H "Content-Type: application/json"
	e.GET("/sendBlob", sendBlob)
	//curl -X GET "http://127.0.0.1:1323/sendStream" -H "Content-Type: application/json"
	e.GET("/sendStream", sendStream)

	//curl -v -X GET "http://127.0.0.1:1323/noContent" -H "Content-Type: application/json"
	e.GET("/noContent", noContent)

	//curl -v -X GET "http://127.0.0.1:1323/redirect" -H "Content-Type: application/json"
	e.GET("/redirect", redirect)

	//curl -v -X GET "http://127.0.0.1:1323/hook" -H "Content-Type: application/json"
	e.GET("/hook", hook)

	// Start server
	e.Logger.Fatal(e.Start(":1324"))
}

// Handler
func contentJSON(c echo.Context) error {
	u := &User{
		Name:  "Jon",
		Email: "jon@labstack.com",
	}
	return c.JSON(http.StatusOK, u)
}

func contentJSONUsePointer(c echo.Context) error {
	u := User{
		Name:  "Jon",
		Email: "jon@labstack.com",
	}
	return c.JSON(http.StatusOK, u)
}

func contentJSONUseNewEncoder(c echo.Context) error {
	u := &User{
		Name:  "Jon",
		Email: "jon@labstack.com",
	}
	c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
	c.Response().WriteHeader(http.StatusOK)
	return json.NewEncoder(c.Response()).Encode(u)
}

func contentJSONPretty(c echo.Context) error {
	u := &User{
		Name:  "Jon",
		Email: "joe@labstack.com",
	}
	return c.JSONPretty(http.StatusOK, u, "  ")
}

func sendFile(c echo.Context) error {
	return c.File(FilePath)
}

func sendAttachment(c echo.Context) error {
	return c.Attachment(FilePath, Name)
}

func sendInline(c echo.Context) error {
	return c.Inline(FilePath, Name)
}

//这个有问题
func sendBlob(c echo.Context) (err error) {
	data := []byte(`0306703,0035866,NO_ACTION,06/19/2006
		0086003,"0005866",UPDATED,06/19/2006`)
	return c.Blob(http.StatusOK, "text/csv", data)
}

func sendStream(c echo.Context) error {
	f, err := os.Open(Image)
	if err != nil {
		return err
	}
	return c.Stream(http.StatusOK, "image/png", f)
}

func noContent(c echo.Context) error {
	return c.NoContent(http.StatusOK)
}

//这个也有问题
func redirect(c echo.Context) error {
	return c.Redirect(http.StatusMovedPermanently, "../sendFile")
}

/*
Context#Response#After(func()) 可以用来注册在写入响应之后调用的函数。
但是如果 “Content-Length” 是未知状态，则不会有任何方法会被执行。
*/
func hook(c echo.Context) error {
	c.Response().Before(func() {
		println("before response")
	})
	c.Response().After(func() {
		println("after response")
	})
	return c.NoContent(http.StatusNoContent)
}

```

## 菜谱 Cookbook
#### Hello World 示例
```
package main
import (
    "net/http"
    "github.com/labstack/echo"
    "github.com/labstack/echo/middleware"
)
func main() {
    // Echo instance
    e := echo.New()
    // Middleware
    e.Use(middleware.Logger())
    e.Use(middleware.Recover())
    // Route => handler
    e.GET("/", func(c echo.Context) error {
        return c.String(http.StatusOK, "Hello, World!\n")
    })
    // Start server
    e.Logger.Fatal(e.Start(":1323"))
}
```
#### 中间件
```
package main

import (
	"net/http"
	"strconv"
	"sync"
	"time"

	"github.com/labstack/echo"
)

type (
	Stats struct {
		Uptime       time.Time      `json:"uptime"`
		RequestCount uint64         `json:"requestCount"`
		Statuses     map[string]int `json:"statuses"`
		mutex        sync.RWMutex
	}
)

func NewStats() *Stats {
	return &Stats{
		Uptime:   time.Now(),
		Statuses: make(map[string]int),
	}
}

// Process is the middleware function.
/*
	func (e *Echo) Use(middleware ...MiddlewareFunc)方法的入参是一个中间件函数
	中间件函数是一个入参数HandlerFunc类型，返回值也是HandlerFunc类型的函数,
	MiddlewareFunc func(HandlerFunc) HandlerFunc
	而HandlerFunc函数是，入参是一个echo.context类型，返回值是一个error类型
	HandlerFunc func(Context) error
*/
func (s *Stats) Process(next echo.HandlerFunc) echo.HandlerFunc {
	return func(c echo.Context) error {
		if err := next(c); err != nil {
			c.Error(err)
		}
		s.mutex.Lock()
		defer s.mutex.Unlock()
		s.RequestCount++
		status := strconv.Itoa(c.Response().Status)
		s.Statuses[status]++
		return nil
	}
}

// Handle is the endpoint to get stats.
func (s *Stats) Handle(c echo.Context) error {
	s.mutex.RLock()
	defer s.mutex.RUnlock()
	return c.JSON(http.StatusOK, s)
}

// ServerHeader middleware adds a `Server` header to the response.
func ServerHeader(next echo.HandlerFunc) echo.HandlerFunc {
	return func(c echo.Context) error {
		c.Response().Header().Set(echo.HeaderServer, "Echo/3.0")
		return next(c)
	}
}
func main() {
	e := echo.New()
	// Debug mode
	e.Debug = true
	//-------------------
	// Custom middleware
	//-------------------
	// Stats
	s := NewStats()
	e.Use(s.Process)
	e.GET("/stats", s.Handle) // Endpoint to get stats
	// Server header
	e.Use(ServerHeader)
	// Handler
	e.GET("/", func(c echo.Context) error {
		return c.String(http.StatusOK, "Hello, World!")
	})
	// Start server
	e.Logger.Fatal(e.Start(":1323"))
}

```
#### JWT
```go

package main

import (
	"net/http"
	"time"

	jwt "github.com/dgrijalva/jwt-go"
	"github.com/labstack/echo"
	"github.com/labstack/echo/middleware"
)

func login(c echo.Context) error {
	/*
		curl -X POST -d 'username=jon' -d 'password=shhh!' localhost:1323/login

		type Token struct {
			Raw       string                 // 原始令牌。 解析令牌时填充
			Method    SigningMethod          // 使用或将要使用的签名方法
			Header    map[string]interface{} // 令牌的第一段
			Claims    Claims                 // 令牌的第二段
			Signature string                 // 令牌的第一段,解析令牌时填充
			Valid     bool                   // 令牌有效吗？ 解析/验证令牌时填充
		}
	*/
	username := c.FormValue("username")
	password := c.FormValue("password")
	if username == "jon" && password == "shhh!" {
		// Create token
		token := jwt.New(jwt.SigningMethodHS256)
		// Set claims
		claims := token.Claims.(jwt.MapClaims)
		claims["name"] = "Jon Snow"
		claims["admin"] = true
		claims["exp"] = time.Now().Add(time.Hour * 72).Unix()
		// Generate encoded token and send it as response.
		t, err := token.SignedString([]byte("secret"))
		if err != nil {
			return err
		}
		return c.JSON(http.StatusOK, map[string]string{
			"token": t,
		})
	}
	return echo.ErrUnauthorized
}

func accessible(c echo.Context) error {
	return c.String(http.StatusOK, "Accessible")
}

func restricted(c echo.Context) error {
	/*
		为什么这里是c.Get("user")，为什么是user字段？没有看到其他的地方定义过这里
		这是因为在JWTConfig中有默认的配置中有默认值为"user"的ContextKey
	*/
	user := c.Get("user").(*jwt.Token)
	claims := user.Claims.(jwt.MapClaims)
	name := claims["name"].(string)
	return c.String(http.StatusOK, "Welcome "+name+"!")
}

func main() {
	e := echo.New()
	// Middleware
	e.Use(middleware.Logger())
	e.Use(middleware.Recover())
	// Login route
	/*
		[root]# curl -X POST -d 'username=jon' -d 'password=shhh!' localhost:1323/login
		{"token":"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhZG1pbiI6dHJ1ZSwiZXhwIjoxNTk1Njc3MjM4LCJuYW1lIjoiSm9uIFNub3cifQ.Phk-WEojuj97wmw20fvRJZb_F6Ztrs7qX2eI0FGj4uw"}
	*/
	e.POST("/login", login)
	// Unauthenticated route
	/*
		[root]# curl -X GET localhost:1323
		Accessible
	*/
	e.GET("/", accessible)
	// Restricted group
	r := e.Group("/restricted")
	/*
		[root]# curl localhost:1323/restricted -H "Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhZG1pbiI6dHJ1ZSwiZXhwIjoxNTk1NjYxMjg0LCJuYW1lIjoiSm9uIFNub3cifQ.VE7QbwPZbJyoA0EDAgmfkGmwvRx5UuHhRY2nVJZK3O4"
		Welcome Jon Snow!
	*/
	r.Use(middleware.JWT([]byte("secret")))

	e.Use(middleware.JWTWithConfig(middleware.JWTConfig{
		SigningKey:  []byte("secret"),
		TokenLookup: "query:token",
	}))
	/*
		[root]# curl localhost:1323/restricted -H "Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhZG1pbiI6dHJ1ZSwiZXhwIjoxNTk1NjYxMjg0LCJuYW1lIjoiSm9uIFNub3cifQ.VE7QbwPZbJyoA0EDAgmfkGmwvRx5UuHhRY2nVJZK3O4"
		Welcome Jon Snow!
	*/
	r.GET("", restricted)
	e.Logger.Fatal(e.Start(":1323"))
}

/*
// JWTConfig defines the config for JWT middleware.
JWTConfig struct {
	//Skipper defines a function to skip middleware.
	//Skipper定义了跳过中间件的功能。如果返回false那么就执行中间件的处理，否则就跳过中间件
	Skipper Skipper


	// Signing key to validate token.
	// Required.
	SigningKey interface{}


	// Signing method, used to check token signing method.签名方法，用于检查令牌签名方法。
	// Optional. Default value HS256.可选的，默认使用的是HS256
	SigningMethod string


	// Context key to store user information from the token into context.
	// 上下文key，用于将用户信息从令牌存储到上下文中。
	比如发送如下的curl命令
	[root@LIN-6A14041F8B1 libs]# curl localhost:1323/restricted -H "Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhZG1pbiI6dHJ1ZSwiZXhwIjoxNTk1NjYxMjg0LCJuYW1lIjoiSm9uIFNub3cifQ.VE7QbwPZbJyoA0EDAgmfkGmwvRx5UuHhRY2nVJZK3O4"
	Welcome Jon Snow!
	可以看到在在请求头上有一个Authorization请求头，这个请求头Bearer单词后面的字符串就是一个token.想要从e.context上下文中获取这个token转换中所存放的一个用户信息，就使用user := c.Get("user").(*jwt.Token)
	// Optional. Default value "user". 可选的，默认值是"user"
	ContextKey string


	// Claims are extendable claims data defining token content.
	// Claims是定义令牌内容的可扩展声明数据。
	// Optional. Default value jwt.MapClaims 可选的。 默认值jwt.MapClaims
	Claims jwt.Claims


	// TokenLookup is a string in the form of "<source>:<name>" that is used
	// to extract token from the request.
	//令牌查找是“ <source>：<name>”形式的字符串，用于从请求中提取令牌。
	// Optional. Default value "header:Authorization".
	// 可选的。 默认值“ header：Authorization”。
	// Possible values:
	//可能的值：
	// - "header:<name>"  -“标题：<名称>”
	// - "query:<name>"   -“查询：<名称>”
	// - "cookie:<name>"  -“ cookie：<名称>”

	// AuthScheme to be used in the Authorization header. 在http请求认证头中使用的身份验证方案
	// Optional. Default value "Bearer". 可选的，默认值是"Bearer"
	AuthScheme string
  }
*/


```

## 参考：

- [1、echo英文官方文档](https://echo.labstack.com/guide )
- [2、echo中文文档](https://www.bookstack.cn/read/go-echo/README.md)
- [3、ECHO系列教程](http://blog.studygolang.com/category/echo-%e7%b3%bb%e5%88%97/)
- [4、ECHO v3教程](https://www.bookstack.cn/read/echo-v3-zh/README.md)
- [5、tizi365的echo教程](https://www.tizi365.com/archives/28.html)
- [6、邱权武的echo教程](https://www.yuque.com/qiuquanwu/lz8ker/trglbn)
- [7、徐新华echo教程](http://blog.studygolang.com/)
- [8、json数据解码的两种方法NewDecoder与Unmarshal](https://www.jianshu.com/p/ba1ffb440c48)
- [9、Golang: 解析JSON数据之三](https://www.cnblogs.com/liuhe688/p/11105571.html)
- [10、JSON Web Token 入门教程  阮一峰](http://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html)
- [11、Json Web Token 详解](https://blog.csdn.net/u010525694/article/details/89052608)
- [12、golang echo 代码详解之 log 篇](https://studygolang.com/articles/11740?fr=sidebar)
- [13、golang JWT包 token验证](https://blog.csdn.net/zhetmdoubeizhanyong/article/details/102568887?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.nonecase&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.nonecase)
